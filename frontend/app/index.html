<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Console cleaner - disables console.log for production -->
    <script src="console-cleaner.js"></script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>AI Thumbnail Copilot</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="canonical" href="https://www.thumbnailcopilot.com/app/" />
    <meta name="description" content="Generate viral YouTube thumbnails and extract image assets using AI with AI Thumbnail Copilot. Instantly create engaging content. No design skills needed." />
    <meta name="author" content="AI Thumbnail Copilot" />
    <meta name="robots" content="index, follow" />
    <meta property="og:title" content="AI Thumbnail Copilot" />
    <meta property="og:description" content="Instantly create stunning YouTube thumbnails or extract assets from images with AI. Enter details, get results!" />
    <meta property="og:url" content="https://thumbnailcopilot.com/" />
    <meta property="og:site_name" content="AI Thumbnail Copilot" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://thumbnailcopilot.com/LOGO.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="AI Thumbnail Copilot" />
    <meta name="twitter:description" content="Instantly create stunning YouTube thumbnails or extract assets from images with AI. Enter details, get results!" />
    <meta name="twitter:image" content="https://thumbnailcopilot.com/LOGO.png" />

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://js.stripe.com/v3/"></script>

    <style>
        :root {
            --bg: #0e0d11;
            --surface: #1c1a23;
            --text: #f5f5f7;
            --text-muted: #a0a0a0;
            --accent: #a78bfa; /* Primary accent (Violet) */
            --accent-hover: #c4b5fd; /* Lighter violet */
            --input-bg: #2a2733;
            --logout: #fca5a5; /* Light red for logout */
            --logout-hover: #f87171; /* Darker red */
            --buy-button: #34d399; /* Green for buy button */
            --buy-button-hover: #6ee7b7; /* Lighter green */
            --radius: 16px;
            --tab-inactive-bg: #2e2e38;
            --tab-inactive-text: #888;
            --tab-inactive-hover-bg: #3a3843;
            --tab-inactive-hover-text: #ccc;
            --card-bg: #222028;
            --select-dropdown-arrow: url('data:image/svg+xml;utf8,%3Csvg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="%23a0a0a0" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"%3E%3Cpolyline points="6 9 12 15 18 9"%3E%3C/polyline%3E%3C/svg%3E');
            --border-color: #3a3843;
            --success-color: #34d399; /* Green */
            --warning-color: #fbbf24; /* Amber */
            --error-color: #f87171; /* Red */
            /* --- New variables for option buttons --- */
            --option-bg: #4a4a5a; /* Light gray */
            --option-bg-hover: #5a5a6a;
            --option-bg-active: #6a6a7a; /* Darker gray */
            --option-text: #e0e0e0;
        }

        #font-button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            /* margin-bottom: 0.75rem; /* Already on the div */
        }
        .font-button {
            padding: 0.5rem 0.8rem;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text);
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s, border-color 0.2s;
            white-space: nowrap;
        }
        .font-button:hover {
            background-color: var(--input-hover-bg, #3a3843);
            border-color: var(--primary-color);
        }
        .font-button.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            font-weight: 600;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            background: var(--bg);
            font-family: 'Outfit', sans-serif;
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem; /* Add padding around the body */
        }

        /* --- Main Container & Tabs --- */
        .tab-bar {
            display: flex;
            width: 100%;
            max-width: 820px;
            border-top-left-radius: var(--radius);
            border-top-right-radius: var(--radius);
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            margin-top: 1rem; /* Reduced top margin */
        }

        .tab-button {
            flex: 1;
            padding: 1rem;
            font-weight: 600;
            font-size: 1rem;
            border: none;
            border-bottom: 3px solid transparent; /* Bottom border for active state */
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            background: var(--tab-inactive-bg);
            color: var(--tab-inactive-text);
            text-align: center;
        }

        .tab-button.active {
            background: var(--surface); /* Match container background */
            color: var(--accent);
            border-bottom: 3px solid var(--accent);
            z-index: 1;
        }

        .tab-button:not(.active):hover {
             background: var(--tab-inactive-hover-bg);
             color: var(--tab-inactive-hover-text);
        }

        .container {
            width: 100%;
            max-width: 820px;
            background: var(--surface);
            border-radius: var(--radius);
            padding: 2rem 1.5rem; /* Adjusted padding */
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative;
            margin-top: 0; /* Remove margin connecting to tabs */
            border: 1px solid var(--border-color); /* Optional border */
            border-top-left-radius: 0;  /* Connect to tabs */
            border-top-right-radius: 0; /* Connect to tabs */
        }

        /* --- Headings --- */
        h1 {
            font-size: clamp(1.8rem, 5vw, 2.6rem); /* Responsive font size */
            color: var(--accent);
            text-align: center;
            margin-bottom: 1rem;
            padding-top: 1rem; /* Reduced padding */
        }

        h2 {
            font-size: clamp(1.3rem, 4vw, 1.6rem);
            color: var(--text);
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }
        /* Center specific H2s if needed */
        #history h2,
        #asset-extraction-content h2,
        #asset-history-display h2 {
            text-align: center;
            color: var(--accent);
            margin-bottom: 1.5rem;
            border-bottom: none;
        }

        /* --- Forms & Inputs --- */
        label {
            font-weight: 600;
            margin-bottom: 0.5rem;
            display: block;
            font-size: 0.95rem;
            color: var(--text-muted);
        }

        input[type="email"],
        input[type="password"],
        input[type="text"],
        textarea,
        input[type="file"] { /* Apply basic styles to file input */
            width: 100%;
            padding: 0.9rem 1rem;
            font-size: 1rem;
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: calc(var(--radius) / 2); /* Slightly smaller radius */
            color: var(--text);
            transition: border-color 0.2s, box-shadow 0.2s;
            margin-bottom: 1rem;
            font-family: inherit; /* Ensure consistent font */
        }

        /* Specific style tweaks for file input */
        input[type="file"] {
            padding: 0.6rem 1rem; /* Adjust padding */
            cursor: pointer;
            color: var(--text-muted);
        }
        input[type="file"]::file-selector-button {
            background: var(--accent);
            color: var(--bg);
            border: none;
            padding: 0.6rem 1rem;
            border-radius: calc(var(--radius) / 3);
            margin-right: 1rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        input[type="file"]::file-selector-button:hover {
            background: var(--accent-hover);
        }
        .file-note {
             font-size: 0.85rem; color: var(--text-muted); margin-top: -0.5rem; margin-bottom: 1rem;
        }


        input:focus, textarea:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(167, 139, 250, 0.3); 
        }

        textarea {
            resize: vertical; /* Allow vertical resize */
            min-height: 80px;
        }

        /* --- Buttons --- */
        button {
            background: var(--accent);
            color: #0e0d11; /* Dark text on accent */
            padding: 0.8rem 1.2rem; /* Adjusted padding */
            border: none;
            border-radius: calc(var(--radius) / 2);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, opacity 0.2s, transform 0.1s;
            display: inline-flex; /* Align icon and text */
            align-items: center;
            justify-content: center;
            gap: 0.5rem; /* Space between icon and text if needed */
        }

        button:hover {
            background: var(--accent-hover);
            transform: translateY(-1px); /* Subtle lift */
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--accent); /* Keep base color */
            transform: none; /* No lift when disabled */
        }
        button:disabled:hover {
             background: var(--accent); /* Prevent hover color change */
        }

        /* Secondary Button Style */
        .secondary-button {
            background: transparent;
            color: var(--accent);
            border: 1px solid var(--accent);
        }
        .secondary-button:hover {
            background: rgba(167, 139, 250, 0.1); /* Subtle background on hover */
            color: var(--accent-hover);
            border-color: var(--accent-hover);
        }
        .secondary-button:disabled {
             opacity: 0.5;
             cursor: not-allowed;
             background: transparent;
             color: var(--accent);
             border-color: var(--accent);
         }
        .secondary-button:disabled:hover {
             background: transparent;
             color: var(--accent);
             border-color: var(--accent);
         }

        /* Buy Credits Button Style (Base) */
        .buy-credits-button {
             background: var(--buy-button);
             color: var(--bg); /* Dark text on green */
        }
        .buy-credits-button:hover {
            background: var(--buy-button-hover);
        }

        /* Specific style for header buy button */
        .header-buy-button {
            padding: 0.4rem 0.8rem; /* Smaller padding */
            font-size: 0.85rem; /* Smaller font */
            margin-left: 0.5rem; /* Add some space from credits */
        }


        /* Logout Button Style */
        #logout-button {
            background: var(--logout);
            color: var(--bg); /* Dark text on red */
            padding: 0.5rem 0.8rem;
            font-size: 0.85rem;
            flex-shrink: 0; /* Prevent shrinking */
        }
        #logout-button:hover {
            background: var(--logout-hover);
        }

        /* --- User Info & Status --- */
        /* Status message base style (used by auth, purchase, asset extraction) */
        #auth-status, #purchase-status, #asset-status {
            font-size: 0.9rem;
            color: var(--text-muted);
            min-height: 1.2em; /* Reserve space */
            text-align: center;
            margin-top: 0.5rem;
            width: 100%; /* Ensure it takes width in flex column */
        }
        #auth-status.error, #purchase-status.error, #asset-status.error { color: var(--error-color); }
        #auth-status.success, #purchase-status.success, #asset-status.success { color: var(--success-color); }
        #auth-status.warning, #purchase-status.warning, #asset-status.warning { color: var(--warning-color); }

        /* Style for purchase status in header */
        .header-purchase-status {
            font-size: 0.8rem; /* Smaller font */
            margin-top: 0.3rem; /* Space below button */
            text-align: center; /* Center text */
            min-height: 1em; /* Reserve space */
            width: 100%; /* Take width within its flex item */
            margin-left: 0;
            margin-right: 0;
        }


        /* Adjusted user info container */
        .user-info-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            justify-content: space-between; /* Space out items */
            align-items: center; /* Vertically center items */
            gap: 1rem; /* Space between items */
            padding: 0.75rem 0; /* Adjusted padding */
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 1.5rem;
        }

        /* --- User Info Centering Rules --- */
        /* Shared styles */
        .credits-display, .user-info-display {
            font-size: 0.9rem;
            color: var(--text-muted);
            background-color: rgba(0,0,0, 0.2);
            padding: 0.3rem 0.7rem;
            border-radius: calc(var(--radius) / 3);
            white-space: nowrap; /* Prevent wrapping */
            display: inline-flex;
            align-items: center;
        }
        .credits-display strong { color: var(--accent); font-weight: 700; }
        .user-info-display span { color: var(--text); font-weight: 600; }
        .user-info-display { flex-grow: 1; justify-content: center; }
        .user-info-container > div:has(#credits-container) { flex-grow: 0; flex-shrink: 0; }

        /* Wrapper for purchase controls in header */
        .purchase-controls {
            display: flex; /* Use flex for button and status */
            flex-direction: column; /* Stack button and status */
            align-items: center; /* Center items horizontally */
        }


        /* --- Results & History (Thumbnails) --- */
        #result h2 { /* Style for the heading above the grid */
             width: 100%;
             text-align: center;
             margin-bottom: 1.5rem;
             color: var(--accent);
             border-bottom: none; /* Remove border for this specific h2 */
             padding-bottom: 0;
        }
        #result {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }

        .thumbnail-results-grid {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(min(300px, 100%), 1fr));
             gap: 1.5rem;
             margin-top: 1rem;
             width: 100%;
        }

        .thumbnail-item {
             display: flex;
             flex-direction: column;
             align-items: center;
             background-color: var(--card-bg); /* Use card background */
             padding: 1rem;
             border-radius: var(--radius);
             border: 1px solid var(--border-color);
             box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .thumbnail-item img {
             max-width: 100%;
             height: auto;
             aspect-ratio: 16 / 9; /* Maintain aspect ratio */
             object-fit: cover; /* Cover the area */
             border-radius: calc(var(--radius) / 2);
             margin-bottom: 1rem;
             background-color: #333; /* Placeholder bg */
             cursor: pointer; /* Indicate clickable for modal */
        }

        .thumbnail-item button {
             width: 100%; /* Make button full width */
             margin-top: auto; /* Push button to bottom if needed */
             padding: 0.6rem 1rem; /* Smaller padding */
             font-size: 0.9rem;
        }

        /* Prompt text display */
        .prompt-text {
            background: var(--input-bg);
            padding: 1rem;
            border-radius: calc(var(--radius) / 2);
            margin-top: 1.5rem; /* Space above */
            font-size: 0.9rem;
            line-height: 1.5;
            color: var(--text-muted);
            border: 1px solid var(--border-color);
            width: 100%; /* Take full width */
        }
        .prompt-text strong { color: var(--text); }


        /* History Card Styling (Thumbnails) */
        #history .card {
            background: var(--card-bg);
            padding: 1rem; /* Slightly less padding */
            border-radius: var(--radius);
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        #history .card img {
             max-width: 100%;
             height: auto;
             aspect-ratio: 16 / 9;
             object-fit: cover;
             border-radius: calc(var(--radius) / 2);
             display: block;
             margin-bottom: 1rem;
             background-color: #333; /* Placeholder bg */
             cursor: pointer; /* Add cursor for modal */
        }
        #history .card p {
            margin: 0.4rem 0;
            font-size: 0.9rem;
            color: var(--text-muted);
            word-wrap: break-word; /* Allow long prompts/titles to wrap */
        }
        #history .card p strong {
             color: var(--text);
             font-weight: 600;
        }
        #history .card p:last-child { /* Style for timestamp */
             font-size: 0.75em;
             color: #888;
             margin-top: 0.8rem;
        }
        #history .card button { /* Style download button in history */
             padding: 0.5rem 1rem;
             font-size: 0.9rem;
             margin-bottom: 1rem;
             width: auto; /* Don't force full width */
        }
         /* Loading/Empty History Message */
         #history p:only-child, #asset-history-display p:only-child {
              color: var(--text-muted);
              text-align: center;
              padding: 2rem 0;
              font-style: italic;
         }
         /* End of History Message */
         .no-more-history {
              text-align:center;
              color: var(--text-muted);
              margin-top:1rem;
              font-style: italic;
              font-size: 0.9em;
         }


        /* --- NEW: Asset Extraction UI Styles --- */
        #asset-extraction-content {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            width: 100%;
        }
        .asset-input-area, .asset-result-area {
            border: 1px dashed var(--border-color);
            padding: 1.5rem;
            border-radius: var(--radius);
            background: rgba(0,0,0,0.1);
        }
        #asset-preview-container, #asset-result-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 1rem;
            min-height: 150px; /* Placeholder height */
            background-color: rgba(255, 255, 255, 0.05); /* Slight background */
            border-radius: calc(var(--radius) / 2);
            overflow: hidden; /* Contain the image */
        }
        #asset-preview-image, #asset-result-image {
            max-width: 80%;
            max-height: 300px;
            object-fit: contain; /* Show the whole image */
            display: none; /* Hidden until loaded */
            border-radius: calc(var(--radius) / 3);
        }
        #asset-result-container {
            min-height: 200px; /* Larger result area */
        }
        #asset-result-container img { /* Style result specifically */
            cursor: pointer; /* Indicate clickable for modal */
        }
        .asset-result-actions { /* Wrapper for download button etc. */
            text-align: center;
            margin-top: 1rem;
        }

        /* --- UPDATED: Asset History Styles --- */
        #asset-history-display {
             margin-top: 1rem;
             padding-top: 1.5rem;
             border-top: 1px solid var(--border-color);
        }
        .asset-card { /* Style for each history item card */
            background: var(--card-bg);
            padding: 1rem;
            border-radius: var(--radius);
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            gap: 0.75rem; /* Space between elements */
        }
        .asset-card-preview-container { /* Container for the single preview image */
            width: 100%;
            max-width: 200px; /* Limit preview size */
            min-height: 100px; /* Ensure some space */
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 0.5rem;
            background-color: rgba(0,0,0,0.1); /* Subtle bg */
            border-radius: calc(var(--radius) / 3);
            border: 1px solid var(--border-color);
        }
        .asset-card-preview-container img { /* Styling for the extracted preview */
            max-width: 90%;
            max-height: 150px; /* Adjust max height as needed */
            object-fit: contain;
            border-radius: calc(var(--radius) / 4);
            background-color: #333; /* Placeholder bg */
            cursor: pointer;
        }
         .asset-card-preview-container p { /* Fallback text if image fails */
            font-size: 0.8em;
            color: var(--text-muted);
            text-align: center;
         }
        .asset-card p { /* General paragraphs in the card */
            margin: 0.2rem 0;
            font-size: 0.9rem;
            color: var(--text-muted);
            word-wrap: break-word;
            text-align: center; /* Center text below image */
        }
        .asset-card p strong {
            color: var(--text);
            font-weight: 600;
        }
        .asset-card p.timestamp { /* Specific style for timestamp */
            font-size: 0.75em;
            color: #888;
            margin-top: 0.5rem;
        }
        .asset-card button { /* Style download button in history */
             padding: 0.4rem 0.8rem;
             font-size: 0.8rem;
             margin-top: 0.5rem;
             width: auto; /* Don't force full width */
        }

        /* --- Other Sections (How-it-works) --- */
        #how-it-works-section {
            text-align: center;
            border-top: 1px solid var(--border-color);
            margin-top: 2rem; /* Restore margin */
            padding-top: 1.5rem; /* Restore padding */
            width: 100%;
        }
        #how-it-works-section h2 { color: var(--accent); border-bottom: none; margin-bottom: 2rem; }
        .steps-container { display: block; text-align: left; }
        .step-card {
            width: 100%;
            margin-bottom: 1.5rem;
            background: var(--input-bg);
            padding: 1.5rem;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
        }
        .step-card .step-number { font-size: 1.5rem; font-weight: 700; color: var(--accent); margin-bottom: 0.5rem; }
        .step-card h3 { margin: 0 0 1rem 0; font-size: 1.2rem; font-weight: 600; color: var(--text); }
        .step-card img { max-width: 100%; height: auto; border-radius: calc(var(--radius) / 2); margin-bottom: 1rem; border: 1px solid var(--border-color); }
        .step-card p { font-size: 1rem; color: var(--text-muted); line-height: 1.6; margin-bottom: 0; }
        #how-it-works-section button { margin-top: 1.5rem; background: var(--accent-hover); color: var(--bg); }

        /* --- Utility & Feedback Styles --- */
        #credit-warning { /* Used for thumbnail gen */
             color: var(--warning-color);
             font-size: 0.9em;
             margin-top: 0.8em;
             padding: 0.5rem;
             background-color: rgba(251, 191, 36, 0.1);
             border: 1px solid var(--warning-color);
             border-radius: calc(var(--radius) / 3);
             text-align: center;
        }
        #credit-warning a {
             color: var(--accent);
             text-decoration: underline;
             font-weight: bold;
             margin-left: 0.5em;
        }
        #credit-warning a:hover { color: var(--accent-hover); }

        .download-error-message {
             color: var(--warning-color);
             font-size: 0.85em;
             margin-top: 0.5rem;
        }

        /* --- Added for AI Badge & How-it-works Intro --- */
        .ai-badge { /* Renamed from openai-badge */
            font-size: 0.8rem;
            color: var(--text-muted);
            text-align: center;
            margin-top: 0.5rem; /* Adjust as needed */
            margin-bottom: 2rem; /* Space before How it Works */
        }
        .how-it-works-intro {
            font-size: 0.95rem;
            color: var(--text-muted);
            margin-bottom: 1.5rem; /* Space before the steps */
            text-align: center;
            max-width: 600px; /* Optional: constrain width */
            margin-left: auto; /* Center if max-width is set */
            margin-right: auto; /* Center if max-width is set */
        }

        /* --- Added for Generation Note --- */
        .generation-note {
             font-size: 0.85rem;
             color: var(--text-muted);
             text-align: center;
             margin-top: 1rem; /* Space below the form/button */
             margin-bottom: 1.5rem; /* Space above the divider/prompt preview */
             padding: 0 1rem; /* Optional padding */
         }


        /* --- Styles for Prompt Option Buttons --- */
        #prompt-options-container {
            margin-top: 1rem; /* Space below niche input */
            margin-bottom: 1.5rem; /* Space above suggest button */
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap */
            gap: 0.5rem; /* Space between buttons */
            align-items: center; /* Align items vertically */
        }
        #prompt-options-container label {
            margin-bottom: 0; /* Remove bottom margin for the label */
            margin-right: 0.5rem; /* Space after label */
            font-size: 0.95rem; /* Match other labels */
            color: var(--text-muted);
            font-weight: 600;
        }
        .option-button {
            padding: 0.4rem 0.8rem; /* Smaller padding */
            font-size: 0.85rem; /* Smaller font */
            background-color: var(--option-bg); /* Light gray */
            color: var(--option-text);
            border: 1px solid transparent; /* Add border for structure */
            border-radius: calc(var(--radius) / 2.5); /* Slightly smaller radius */
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s, transform 0.1s;
            font-weight: normal;
            display: inline-flex; align-items: center; justify-content: center;
            gap: 0; /* Remove gap */
        }
        .option-button:hover {
            background-color: var(--option-bg-hover);
            border-color: var(--border-color);
            transform: none; /* No lift on hover */
        }
        .option-button.active {
            background-color: var(--option-bg-active); /* Darker gray */
            border-color: var(--accent); /* Highlight border when active */
            color: var(--text);
            font-weight: 600; /* Make active text bolder */
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.2); /* Subtle inner shadow */
        }


        /* --- Responsive Adjustments --- */
        @media (max-width: 600px) {
             body { padding: 0.5rem; }
             .container { padding: 1.5rem 1rem; }
             h1 { padding-top: 1rem; }
             .tab-button { font-size: 0.9rem; padding: 0.8rem 0.5rem; }

             /* Responsive header bar */
             .user-info-container { flex-direction: column; align-items: stretch; padding-bottom: 1rem; }
             .user-info-container > div, .user-info-container > button#logout-button { text-align: center; width: 100%; margin-bottom: 0.5rem; }
             .credits-display, .user-info-display { justify-content: center; }
             .purchase-controls { width: auto; margin-bottom: 0; text-align: center; }
             #logout-button { order: 2; margin-top: 0.5rem; margin-bottom: 0; width: 100%; }
             .header-buy-button { width: auto; margin-left: 0; }
             .user-info-container > div:has(#credits-container) { order: 1; align-items: center; }
             .user-info-display { order: 0; flex-grow: 0; }


             button { padding: 0.8rem 1rem; font-size: 0.95rem; }

             #how-it-works-section { padding: 1.5rem 1rem; margin-top: 1rem; }
             #how-it-works-section h2 { font-size: 1.4rem; margin-bottom: 1.5rem;}
             .step-card h3 { font-size: 1.1rem; }
             .step-card p { font-size: 0.95rem; }

             .ai-badge { margin-bottom: 1.5rem; }
             .how-it-works-intro { margin-bottom: 1rem; }

             #prompt-options-container { gap: 0.4rem; justify-content: center; }
              #prompt-options-container label { width: 100%; text-align: center; margin-bottom: 0.5rem; margin-right: 0; }
             .option-button { padding: 0.3rem 0.6rem; font-size: 0.8rem; }

             /* Asset Extraction Responsive */
             .asset-card-previews { grid-template-columns: 1fr; } /* Stack previews on mobile */
             .asset-card-previews img { max-height: 100px; }
             /* Simplified Asset History Card for Mobile */
             .asset-card { flex-direction: column; align-items: center; }
             .asset-card-preview-container { max-width: 150px; margin-bottom: 0.75rem; }

        }

        /* --- NEW: Style Profile UI Styles --- */
        #style-profile-content {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            width: 100%;
        }
        
        .style-upload-area {
            background: var(--surface);
            padding: 1.5rem;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
        }
        
        .thumbnail-upload-container {
            margin: 1rem 0;
        }
        
        .thumbnail-previews {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .thumbnail-preview {
            position: relative;
            width: 150px;
            height: 100px;
            border-radius: calc(var(--radius) / 2);
            overflow: hidden;
            border: 1px solid var(--border-color);
        }
        
        .thumbnail-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .thumbnail-preview .remove-thumbnail {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            padding: 0;
        }
        
        .json-editor-container {
            background: var(--input-bg);
            border-radius: calc(var(--radius) / 2);
            padding: 1rem;
            margin: 1rem 0;
        }
        
        .saved-styles-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .style-card {
            background: var(--surface);
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .style-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .style-card-header h4 {
            color: var(--accent);
            margin: 0;
            cursor: pointer;
            position: relative;
            display: inline-block;
            padding-right: 20px;
        }
        
        .style-card-header h4::after {
            content: '▼';
            font-size: 0.7em;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.2s ease;
        }
        
        .style-card-header h4:hover {
            color: var(--accent-hover);
        }
        
        .style-card.expanded .style-card-header h4::after {
            transform: translateY(-50%) rotate(180deg);
        }
        
        .style-card-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .style-card-actions button {
            padding: 0.4rem 0.8rem;
            font-size: 0.85rem;
        }
        
        .style-card-content {
            max-height: 200px;
            overflow-y: auto;
            background: var(--input-bg);
            border-radius: calc(var(--radius) / 2);
            padding: 0.5rem;
            font-family: monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            display: none;
        }
        
        .style-card.expanded .style-card-content {
            display: block;
        }
        
        .style-card.editing .style-card-content {
            display: none;
        }
        
        .style-edit-container {
            margin-top: 0.5rem;
            display: none;
        }
        
        .style-card.editing .style-edit-container {
            display: block;
        }
        
        .style-edit-container textarea {
            width: 100%;
            font-family: monospace;
            font-size: 0.85rem;
            min-height: 150px;
            margin-bottom: 0.5rem;
            background: var(--input-bg);
            color: var(--text);
            border: 1px solid var(--border-color);
            border-radius: calc(var(--radius) / 3);
            padding: 0.5rem;
            resize: vertical;
        }
        
        .style-edit-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }

        /* --- simple image modal --- */
        #img-modal{position:fixed;inset:0;background:rgba(0,0,0,.85);display:none;
             align-items:center;justify-content:center;z-index:9999}
        #img-modal img{max-width:90vw;max-height:90vh;border-radius:12px}

        /* --- NEW: Canvas Controls Styles --- */
        .tool-controls, .color-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 0.5rem;
        }
        
        .tool-button {
            padding: 0.5rem 1rem;
            background-color: var(--option-bg);
            color: var(--text);
            border: none;
            border-radius: calc(var(--radius) / 4);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .tool-button:hover {
            background-color: var(--option-bg-hover);
        }
        
        .tool-button.active {
            background-color: var(--accent);
            color: var(--bg);
        }
        
        .color-button {
            width: 30px;
            height: 30px;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .color-button:hover {
            transform: scale(1.1);
        }
        
        .color-button.active {
            border: 2px solid var(--text);
            transform: scale(1.2);
        }
        
        .upload-sketch-container {
            margin-top: 1rem;
            padding: 1rem;
            border: 1px dashed var(--border-color);
            border-radius: var(--radius);
            text-align: center;
        }
        
        .upload-sketch-container p {
            margin-bottom: 0.5rem;
            color: var(--text-muted);
        }
        
        /* --- Modal Styles --- */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.9);
        }
        
        /* --- Tooltip Styles --- */
        .tooltip-container {
            display: inline-flex;
            align-items: center;
            margin-left: 5px;
            position: relative;
        }
        
        .tooltip-icon {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: var(--text-muted);
            color: var(--bg);
            font-size: 12px;
            font-weight: bold;
            cursor: help;
        }
        
        .tooltip-text {
            visibility: hidden;
            width: 250px;
            background-color: var(--bg-secondary);
            color: var(--text);
            text-align: center;
            border-radius: var(--radius);
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            border: 1px solid var(--border-color);
            font-weight: normal;
            font-size: 0.85rem;
        }
        
        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: var(--bg-secondary) transparent transparent transparent;
        }
        
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        /* --- Sub-tab Styles --- */
        .sub-tab-bar {
            display: flex;
            margin-bottom: 1.5rem; /* Space below sub-tabs */
            border-bottom: 1px solid var(--border-color);
        }

        .sub-tab-button {
            flex-grow: 1; /* Make buttons take equal width */
            padding: 0.75rem 1rem;
            font-weight: 600;
            font-size: 0.95rem;
            border: none;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            transition: color 0.2s, border-bottom 0.2s;
            text-align: center;
            border-bottom: 3px solid transparent;
        }

        .sub-tab-button.active {
            color: var(--accent);
            border-bottom: 3px solid var(--accent);
        }

        .sub-tab-button:not(.active):hover {
            color: var(--text);
        }

        .sub-tab-content {
            display: none; /* Hidden by default */
            width: 100%;
        }
        .sub-tab-content.active {
            display: block; /* Show active content */
        }

        /* --- Precision Mode Preview Buttons --- */
        .precision-use-button, .precision-edit-button {
            padding: 0.4rem 0.8rem; /* Smaller padding */
            font-size: 0.85rem;    /* Smaller font */
            border-radius: var(--radius-sm, 4px); /* Use a smaller radius if defined, else default */
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s, box-shadow 0.2s;
            margin-top: 0.25rem;
        }

        .precision-use-button {
            background-color: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .precision-use-button:hover {
            background-color: var(--accent-hover, hsl(from var(--accent) h s calc(l - 5%)));
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .precision-edit-button {
            background-color: var(--button-secondary-bg, var(--bg-secondary));
            color: var(--button-secondary-text, var(--text));
            border-color: var(--button-secondary-border, var(--border-color));
        }

        .precision-edit-button:hover {
            background-color: var(--button-secondary-hover-bg, hsl(from var(--bg-secondary) h s calc(l - 5%)));
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        /* Style for the image itself to indicate it's clickable */
        #precision-previews-grid img {
            cursor: pointer;
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }
        #precision-previews-grid img:hover {
            transform: scale(1.03);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        /* --- Image Modal for Previews --- */
        #img-modal {
            /* display: none; Already set inline, but good for clarity */
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.85);
            /* Use flex to center, replacing existing onclick for background */ 
            display: flex; 
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        #img-modal img {
            display: block;
            max-width: 90%;
            max-height: 90vh;
            margin: auto;
            border-radius: var(--radius);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            object-fit: contain;
        }

        /* --- Preview Image Hover Actions --- */
        .preview-cell {
            position: relative;
            overflow: hidden;
        }

        .preview-actions-container {
            position: absolute;
            bottom: 0px; /* Aligned to the very bottom */
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 0.5rem; /* A bit more padding for touch */
            background-color: rgba(var(--bg-rgb, 255,255,255), 0.1);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            border-top: 1px solid rgba(var(--border-rgb, 200,200,200), 0.2);
            opacity: 0;
            transform: translateY(100%);
            transition: opacity 0.25s ease-out, transform 0.25s ease-out;
            pointer-events: none;
        }

        .preview-cell:hover .preview-actions-container {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        /* Ensure buttons inside are styled as before */
        .preview-actions-container .precision-use-button,
        .preview-actions-container .precision-edit-button {
            margin-top: 0; /* Remove top margin if it was added for standalone buttons */
        }

        /* --- Loading Spinner --- */
        .loading-spinner, .loading-spinner-inline {
            display: inline-block;
            width: 1.1em;
            height: 1.1em;
            border: 3px solid rgba(var(--text-rgb, 0,0,0), 0.2);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 0.8s linear infinite;
            margin-right: 0.6em;
            vertical-align: -0.15em;
        }
        
        .loading-spinner-inline {
            width: 1em;
            height: 1em;
            border-width: 2px;
        }
        
        .button-loading {
            opacity: 0.8;
            cursor: not-allowed;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Thumbnail Carousel Styles */
        #left-carousel, #right-carousel {
            position: fixed;
            top: 0;
            bottom: 0;
            width: 495px; /* Total width for 2 columns (240px*2 + 15px gap) */
            overflow: hidden;
            pointer-events: none; /* Allow interaction with elements behind */
            z-index: -1; /* Behind the main content */
            height: 100vh; /* Full viewport height */
        }
        
        #left-carousel {
            left: 0;
        }
        
        #right-carousel {
            right: 0;
        }
        
        .carousel-thumbnail {
            position: absolute;
            width: 240px; /* Larger thumbnails */
            height: 140px; /* Larger thumbnails */
            border-radius: var(--radius, 8px);
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            pointer-events: auto; /* Re-enable pointer events for thumbnails */
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        
        .carousel-thumbnail:hover {
            transform: scale(1.05) translateX(10px);
            z-index: 1;
            opacity: 0.9;
        }
        
        #right-carousel .carousel-thumbnail:hover {
            transform: scale(1.05) translateX(-10px);
        }
        
        .carousel-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        /* Media query to hide carousels on small screens */
        @media (max-width: 1800px) {
            #left-carousel, #right-carousel {
                display: none;
            }
        }

</style>
<style id="dynamic-font-styles"></style>
</head>
<body>

 <!-- Thumbnail Carousel Containers -->
 <div id="left-carousel"></div>
 <div id="right-carousel"></div>

 <div class="tab-bar">
     <button id="tab-prompt-gen" class="tab-button active">Image Generation</button>

     <button id="tab-asset-extraction" class="tab-button">Object Extraction</button>
     <button id="tab-style-profile" class="tab-button">Style Profile</button>
 </div>

 <div class="container">
     <h1>✨ AI Thumbnail Copilot</h1>

     <div id="auth">
         <h2>Login or Sign up</h2>
         <p id="signup-encouragement" style="color: var(--accent); text-align: center; margin-bottom: 1.5rem; font-size: 1.05rem;">
              ✨ New here? Sign up to get <strong>15 free credits</strong> and start creating amazing thumbnails! ✨
         </p>
         <label for="auth-email">Email</label>
         <input type="email" id="auth-email" placeholder="you@example.com" required />
         <label for="auth-password">Password</label>
         <input type="password" id="auth-password" placeholder="••••••••" required />
         <div style="display: flex; gap: 1rem; margin-top: 0.5rem;">
              <button onclick="login()" style="flex: 1;">Log In</button>
              <button class="secondary-button" onclick="signup()" style="flex: 1;">Sign Up</button>
         </div>
         <div style="text-align: center; margin-top: 0.5rem;">
              <a href="#" id="forgot-password-link" style="color: var(--accent); text-decoration: none; font-size: 0.9rem;">Forgot Password?</a>
         </div>
         <div class="auth-separator" style="display: flex; align-items: center; margin: 1rem 0;">
              <div style="flex-grow: 1; height: 1px; background-color: var(--border-color);"></div>
              <span style="padding: 0 10px; color: var(--text-muted);">or</span>
              <div style="flex-grow: 1; height: 1px; background-color: var(--border-color);"></div>
         </div>
         <button onclick="signInWithGoogle()" class="google-signin-btn" style="display: flex; justify-content: center; align-items: center; gap: 8px; width: 100%; padding: 10px; border-radius: var(--radius); background-color: white; color: #444; border: 1px solid #ddd; cursor: pointer;">
              <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 18 18"><path fill="#4285F4" d="M16.51 8H8.98v3h4.3c-.18 1-.74 1.48-1.6 2.04v2.01h2.6a7.8 7.8 0 0 0 2.38-5.88c0-.57-.05-.66-.15-1.18Z"></path><path fill="#34A853" d="M8.98 17c2.16 0 3.97-.72 5.3-1.94l-2.6-2a4.8 4.8 0 0 1-7.18-2.54H1.83v2.07A8 8 0 0 0 8.98 17Z"></path><path fill="#FBBC05" d="M4.5 10.52a4.8 4.8 0 0 1 0-3.04V5.41H1.83a8 8 0 0 0 0 7.18l2.67-2.07Z"></path><path fill="#EA4335" d="M8.98 4.18c1.17 0 2.23.4 3.06 1.2l2.3-2.3A8 8 0 0 0 1.83 5.4L4.5 7.49a4.8 4.8 0 0 1 4.48-3.3Z"></path></svg>
              Continue with Google
         </button>
         <p id="auth-status"></p>
     </div>

     <!-- Forgot Password Modal -->
     <div id="forgot-password-modal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center;">
         <div class="modal-content" style="background-color: var(--bg); padding: 2rem; border-radius: var(--radius); max-width: 400px; width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.2);">
             <h3 style="margin-top: 0;">Reset Password</h3>
             <p style="color: var(--text-muted);">Enter your email address and we'll send you a password reset link.</p>
             <label for="forgot-password-email">Email</label>
             <input type="email" id="forgot-password-email" placeholder="you@example.com" required style="width: 100%; margin-bottom: 1rem;" />
             <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                 <button onclick="resetPassword()" style="flex: 1;">Send Reset Link</button>
                 <button class="secondary-button" onclick="closeForgotPasswordModal()" style="flex: 1;">Cancel</button>
             </div>
             <p id="forgot-password-status" style="margin-top: 1rem; text-align: center;"></p>
         </div>
     </div>

     <!-- Update Password Modal -->
     <div id="update-password-modal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center;">
         <div class="modal-content" style="background-color: var(--bg); padding: 2rem; border-radius: var(--radius); max-width: 400px; width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.2);">
             <h3 style="margin-top: 0;">Set New Password</h3>
             <p style="color: var(--text-muted);">Please enter your new password below.</p>
             <label for="new-password">New Password</label>
             <input type="password" id="new-password" placeholder="Enter new password" required style="width: 100%; margin-bottom: 1rem;" />
             <label for="confirm-password">Confirm Password</label>
             <input type="password" id="confirm-password" placeholder="Confirm new password" required style="width: 100%; margin-bottom: 1rem;" />
             <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                 <button onclick="updatePassword()" style="flex: 1;">Update Password</button>
             </div>
             <p id="update-password-status" style="margin-top: 1rem; text-align: center;"></p>
         </div>
     </div>

     <div id="main-app-content" style="display: none; width: 100%;">

         <div class="user-info-container">
             <div style="display: flex; flex-direction: column; align-items: flex-start; gap: 0.5rem;">
                 <div id="credits-container" class="credits-display" style="display: none;">
                      Credits: <strong id="credits-display">--</strong>
                 </div>
                 <div class="purchase-controls" style="display: none;">
                      <button class="buy-credits-button header-buy-button" data-price-id="price_1RIwfTFj9LYfI1R0gVPq3kRS"> Buy 50 Credits (€9.99) </button>
                      <p id="purchase-status" class="header-purchase-status"></p>
                 </div>
             </div>
             <div id="user-info-display" class="user-info-display" style="display: none;">
                  User: <span id="user-email-display"></span>
             </div>
             <button id="logout-button" onclick="logout()">Log Out</button>
         </div>

         <div id="prompt-gen-tab-content" style="display: none; width: 100%;">
            <div class="sub-tab-bar">
                <div style="display: flex; align-items: center; flex-grow: 1;">
                    <button id="sub-tab-precision" class="sub-tab-button active">Shuffle Mode</button>
                    <div class="tooltip-container">
                        <div class="tooltip-icon">?</div>
                        <span class="tooltip-text">Get 6 fast, distinct thumbnails for your description. If you want a more specific choice, go to "QUICK MODE"</span>
                    </div>
                </div>
                <div style="display: flex; align-items: center; flex-grow: 1;">
                    <button id="sub-tab-quick" class="sub-tab-button">Quick Mode</button>
                    <div class="tooltip-container">
                        <div class="tooltip-icon">?</div>
                        <span class="tooltip-text">Get an editable custom made visual prompt for your video that you can use to create 2 thumbnails</span>
                    </div>
                </div>
            </div>

            <div id="precision-mode-content" class="sub-tab-content active">
                <div id="precision-step1-video-topic" style="padding: 1rem;">
                    <label for="video-topic-input" style="display: block; margin-bottom: 0.75rem; font-weight: 600;">What is your video about?</label>
                    <textarea id="video-topic-input" rows="4" placeholder="e.g., A detailed review of the latest iPhone, a travel vlog about my trip to Japan, a tutorial on how to bake sourdough bread..." style="width: 100%; margin-bottom: 1rem; background-color: var(--input-bg); color: var(--text); padding: 0.8rem 1rem; border-radius: var(--radius); border: 1px solid var(--border-color); font-family: 'Outfit', sans-serif; resize: vertical;"></textarea>
                    <button id="submit-video-topic" style="width: 100%; padding: 0.8rem 1rem; font-weight: 600;">Submit (Cost: 1 Credit)</button>
                    <p id="precision-step1-status" style="margin-top: 0.75rem; text-align: center; color: var(--text-muted);"></p>
                </div>

                <div id="precision-previews-container" style="margin-top: 2rem; display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <button id="new-thumbnail-button" style="padding: 0.5rem 0.8rem; font-size: 0.9rem; background-color: var(--bg-secondary); color: var(--text); border: 1px solid var(--border-color); border-radius: var(--radius-sm); cursor: pointer;">New Thumbnail</button>
                        <h3 style="text-align: center; margin: 0; flex-grow: 1;">Generated Previews (Low Quality)</h3>
                    </div>
                    <div id="precision-previews-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                        <!-- Preview images will be populated here by JavaScript -->
                    </div>
                    <button id="regenerate-previews-button" style="display: none; margin: 1.5rem auto 0.5rem; padding: 0.7rem 1.2rem; font-weight: 500;">
                        <span class="loading-spinner" style="display: none;"></span> Regenerate All Previews (Cost: 1 Credit)
                    </button>
                    <p id="precision-previews-status" style="margin-top: 0.5rem; text-align: center; color: var(--text-muted);"></p>
                </div>

                <!-- NEW: Container for "Use" flow -->
                <div id="precision-use-flow-container" style="display: none; padding: 1rem; margin-top: 1rem; border: 1px solid var(--border-color); border-radius: var(--radius);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <button id="back-to-previews-button" style="padding: 0.5rem 0.8rem; font-size: 0.9rem;">&larr; Back to Previews</button>
                        <h3 style="text-align: center; margin: 0; flex-grow: 1;">Refine Your Thumbnail</h3>
                    </div>
                    <div style="text-align: center; margin-bottom: 1rem;">
                        <img id="enlarged-preview-image" src="" alt="Selected Preview" style="max-width: 100%; max-height: 400px; border-radius: var(--radius); border: 1px solid var(--border-color); object-fit: contain; margin: 0 auto; display: block;">
                    </div>
                    <!-- Canvas Editor Area -->
                    <div id="canvas-editor-area" style="margin-top: 1rem; display: none; /* Initially hidden */">
                        <div id="canvas-container" style="margin: 0 auto; width: fit-content; max-width: 100%;">
                            <canvas id="image-text-canvas" style="border: 1px solid var(--border-color); border-radius: var(--radius); max-width: 100%; height: auto;"></canvas>
                        </div>
                        <div id="text-controls-container" style="margin-top: 1rem; padding: 1rem; background-color: var(--bg-secondary); border-radius: var(--radius);">
                            <button id="add-text-object-button" class="control-button" style="margin-bottom: 0.75rem; padding: 0.6rem 0.8rem; width: 100%;">+ Add New Text</button>
                            <div id="text-input-details-container" style="display: none; flex-direction: column; gap: 0.75rem;">
                                <div style="margin-bottom: 0.75rem;">
                                    <label for="caption-input" style="display: block; margin-bottom: 0.5rem; font-weight: 500;">Caption Text:</label>
                                    <input type="text" id="caption-input" placeholder="Enter text for thumbnail" style="width: 100%; padding: 0.6rem 0.8rem; border-radius: var(--radius-sm); border: 1px solid var(--border-color); background-color: var(--input-bg); color: var(--text);">
                                </div>
                                <!-- Placeholder for more controls: font, size, color, position -->
                                <div style="margin-bottom: 0.75rem;">
                                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 500;">Font:</label>
                                    <div id="font-button-container" style="margin-bottom: 0.75rem;">
                                        <!-- Font buttons will be dynamically inserted here -->
                                    </div>
                                </div>
                                <div style="margin-bottom: 1rem;">
                                    <label for="font-size-input" style="display: block; margin-bottom: 0.5rem; font-weight: 500;">Font Size (px):</label>
                                    <input type="number" id="font-size-input" value="50" min="10" max="200" style="width: 100px; padding: 0.6rem 0.8rem; border-radius: var(--radius-sm); border: 1px solid var(--border-color); background-color: var(--input-bg); color: var(--text);">
                                </div>
                                <div style="margin-bottom: 1rem;">
                                    <label for="text-color-picker" style="display: block; margin-bottom: 0.5rem; font-weight: 500;">Text Color:</label>
                                    <input type="color" id="text-color-picker" value="#FFFFFF" style="padding: 0.2rem; border-radius: var(--radius-sm); border: 1px solid var(--border-color); background-color: var(--input-bg); cursor: pointer; width: 100px; height: 40px;">
                                </div>
                            </div>
                            <div id="final-image-actions-container" style="display: flex; justify-content: space-between; gap: 1rem; margin-top: 0.75rem; display: none;">
                                <button id="download-final-image-button" class="secondary-button" style="flex-grow: 1; padding: 0.8rem 1rem; font-weight: 600;">Download Image</button>
                                <button id="upscale-final-image-button" style="flex-grow: 1; padding: 0.8rem 1rem; font-weight: 600;">Upscale with Clarity AI (Cost: 2 Credits)</button>
                            </div>
                        </div>
                    </div>
                    <p id="precision-hq-status" style="margin-top: 0.75rem; text-align: center; color: var(--text-muted);"></p>
                </div>
            </div>
            </div>

            <div id="quick-mode-content" class="sub-tab-content">
             <form id="thumbnailForm">
                 <label for="title">Video Title</label>
                 <input type="text" id="title" placeholder="e.g. How I Got 1M Views From Shorts" required />
                 <label for="niche">Channel Niche / Video Topic</label>
                 <input type="text" id="niche" placeholder="e.g. Tech Reviews, Travel Vlogs, Cooking Tutorials" required />

                 <div id="prompt-options-container">
                      <label>Special requests:</label>
                      <button type="button" class="option-button">no text</button>
                      <button type="button" class="option-button">no humans</button>
                      <button type="button" class="option-button">cartoon style</button>
                      <button type="button" class="option-button">photorealistic</button>
                      <button type="button" class="option-button">pixel art</button>
                      <button type="button" class="option-button">3d render</button>
                      <button type="button" class="option-button">oil painting</button>
                      <button type="button" class="option-button">watercolor</button>
                      <button type="button" class="option-button">retro</button>
                      <button type="button" class="option-button">bright and cheerful</button>
                      <button type="button" class="option-button">dark and mysterious</button>
                 </div>
                 <label for="styleProfileSelect">Select Style Profile (Optional):</label>
                 <select id="styleProfileSelect" name="styleProfile" style="appearance: none; -webkit-appearance: none; -moz-appearance: none; background-color: var(--input-bg); color: var(--text); padding: 0.8rem 1rem; border-radius: var(--radius); border: 1px solid var(--border-color); width: 100%; font-family: 'Outfit', sans-serif; cursor: pointer; background-image: var(--select-dropdown-arrow); background-repeat: no-repeat; background-position: right 1rem center; background-size: 1rem;">
                     <option value="">-- None --</option>
                 </select>
                 <div style="margin-top: 1rem; text-align: center;"> <button type="submit" id="generate-prompt-button">Suggest Prompt Idea</button>
                 </div>
             </form>

             <div id="prompt-preview" style="display: none; margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--border-color);">
                 <label for="custom-prompt">Edit AI Prompt Suggestion (or enter your own)</label>
                 <textarea id="custom-prompt" rows="4" placeholder="Describe the thumbnail you want the AI to create..."></textarea>
                 <button onclick="confirmPrompt()" id="confirm-prompt-button" style="margin-top: 0.5rem; width: 100%;">Generate 2 Thumbnails (Cost: 2 Credits)</button>
                 <p id="credit-warning" style="display: none;"></p>
             </div>

             <div id="result">
                 </div>

             <div style="margin-top: 2rem; text-align: center;">
                 <button id="history-button" onclick="fetchHistory()" class="secondary-button">Show My History</button>
             </div>

             <div id="history" style="display: none; margin-top: 1rem;">
                  </div>
             <div id="history-load-more-container" style="text-align: center; margin-top: 1rem; display: none;">
                 <button id="history-load-more-button" class="secondary-button">Load More History</button>
             </div>
            </div>
         </div>

         <div id="asset-extraction-content" style="display: none; width: 100%;">
             <h2>✂️ Asset Extractor</h2>
             <p style="text-align: center; color: var(--text-muted); margin-top: -1rem; margin-bottom: 1rem;">Upload a PNG image, describe the object you want to keep, and the AI will attempt to remove the background.</p>

             <div class="asset-input-area">
                 <label for="asset-source-image">1. Upload Source Image (PNG or JPG/JPEG)</label>
                 <input type="file" id="asset-source-image" accept="image/png,image/jpeg,image/jpg" required />
                 <p class="file-note">The AI works best with clear subjects against contrasting backgrounds.</p>
                 <div id="asset-preview-container">
                      <img id="asset-preview-image" src="" alt="Selected image preview" />
                      <p id="asset-preview-placeholder" style="color: var(--text-muted);">Image preview will appear here</p>
                 </div>

                 <label for="asset-description" style="margin-top: 1rem;">2. Describe the Asset to Extract</label>
                 <input type="text" id="asset-description" placeholder="e.g., 'the cat', 'the logo in the center', 'person wearing red'" required />

                 <button id="extract-asset-button" style="margin-top: 1rem; width: 100%;" disabled>Extract Asset (Cost: 3 Credits)</button>
                 <p id="asset-status"></p>
             </div>

             <div class="asset-result-area" id="asset-result-area" style="display: none;">
                 <h3>Extraction Result:</h3>
                 <div id="asset-result-container">
                      <img id="asset-result-image" src="" alt="Extracted asset result" />
                 </div>
                 <div class="asset-result-actions">
                      <button id="asset-download-button" class="secondary-button" style="display: none;">⬇ Download Extracted PNG</button>
                 </div>
                 <p class="generation-note">Note: AI background removal isn't perfect. Complex backgrounds or subjects might have artifacts.</p>
             </div>

              <div style="margin-top: 2rem; text-align: center;">
                 <button id="asset-history-button" class="secondary-button">Show My Asset History</button>
             </div>

             <div id="asset-history-display" style="display: none; margin-top: 1rem;">
                  </div>
             <div id="asset-history-load-more-container" style="text-align: center; margin-top: 1rem; display: none;">
                 <button id="asset-history-load-more-button" class="secondary-button">Load More Asset History</button>
             </div>

         </div>

         <div id="style-profile-content" style="display: none; width: 100%;">
              <h2>🎨 Style Profile</h2>
              <p style="text-align: center; color: var(--text-muted); margin-top: -1rem; margin-bottom: 1rem;">Upload thumbnails you like and get an AI-generated style profile to use in your future thumbnails.</p>
              
              <div class="style-upload-area">
                  <h3>Upload Reference Thumbnails</h3>
                  <p>Select up to 5 thumbnails that represent the style you want to analyze.</p>
                  <div class="thumbnail-upload-container">
                      <input type="file" id="style-thumbnails-upload" accept="image/png, image/jpeg, image/jpg" multiple>
                      <p class="file-note">For best results, choose thumbnails with a consistent style.</p>
                  </div>
                  <div id="thumbnail-previews" class="thumbnail-previews"></div>
                  <button id="analyze-style-button" style="margin-top: 1rem; width: 100%;">Analyze Style (Cost: 5 Credits)</button>
                  <p id="style-analysis-status"></p>
              </div>
              
              <div id="style-profile-result" style="display: none; margin-top: 2rem;">
                  <h3>Style Profile</h3>
                  <div class="json-editor-container">
                      <textarea id="style-profile-json" rows="10" style="width: 100%; font-family: monospace;" spellcheck="false"></textarea>
                  </div>
                  <div class="style-profile-actions">
                      <div class="style-name-input" style="margin-top: 1rem;">
                          <label for="style-name">Name this style:</label>
                          <input type="text" id="style-name" placeholder="e.g., Vibrant Tech Style">
                          <p id="style-name-warning" class="warning" style="margin-top: 0.25rem; font-size: 0.9rem; display: none;">Please enter a name for this style</p>
                      </div>
                      <button id="save-style-button" class="secondary-button" style="margin-top: 1rem; width: 100%;">Save Style Profile</button>
                  </div>
              </div>
              
              <div id="saved-styles-section" style="margin-top: 2rem;">
                  <h3>My Styles</h3>
                  <div id="saved-styles-list" class="saved-styles-list">
                      <p id="no-saved-styles-message">You haven't saved any style profiles yet.</p>
                  </div>
              </div>
         </div>
         </div> <p class="ai-badge">🚀 Powered by advanced AI image generation & editing</p>

 </div> <div id="img-modal" style="display: none;">
     <img src="" alt="preview"/>
 </div>

 <div id="edit-modal" style="display: none; position: fixed; z-index: 1002; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.85); justify-content: center; align-items: center; padding: 20px; box-sizing: border-box;">
    <div style="background-color: var(--bg-primary); border-radius: var(--radius); padding: 1.5rem; max-width: 600px; width: 100%; position: relative; box-shadow: 0 8px 25px rgba(0,0,0,0.3);">
        <button id="close-edit-modal" style="position: absolute; right: 1rem; top: 1rem; background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text);">&times;</button>
        <h3 style="margin-top: 0; text-align: center;">Refine Your Thumbnail</h3>
        <div style="text-align: center; margin-bottom: 1rem;">
            <img id="edit-preview-image" src="" alt="Selected Preview" style="max-width: 100%; max-height: 300px; border-radius: var(--radius); border: 1px solid var(--border-color); object-fit: contain; margin: 0 auto; display: block;">
        </div>
        <div style="margin-bottom: 1rem;">
            <label for="edit-instructions" style="display: block; margin-bottom: 0.5rem;">What would you like to change?</label>
            <textarea id="edit-instructions" placeholder="Describe in natural language what you want to change about this image..." style="width: 100%; min-height: 100px; padding: 0.75rem; border-radius: var(--radius-sm); border: 1px solid var(--border-color); background: var(--bg-secondary); color: var(--text); font-family: inherit; resize: vertical;"></textarea>
        </div>
        <div style="display: flex; justify-content: space-between; gap: 1rem;">
            <button id="cancel-edit-button" style="flex: 1; padding: 0.75rem; border-radius: var(--radius-sm); border: 1px solid var(--border-color); background: var(--bg-secondary); color: var(--text); cursor: pointer;">Cancel</button>
            <button id="apply-edit-button" style="flex: 1; padding: 0.75rem; border-radius: var(--radius-sm); background-color: var(--accent); color: white; border: none; cursor: pointer;">Generate New Previews</button>
        </div>
    </div>
 </div>


 <!-- Thumbnail Carousel Script -->
 <script src="js/thumbnail-carousel.js"></script>

 <script>
     // --- Helper function to show loading spinner on buttons ---
     function showLoadingSpinner(button, isLoading, loadingText = 'Loading...') {
       if (!button) return;
       
       const originalText = button.getAttribute('data-original-text') || button.textContent;
       
       if (isLoading) {
         // Save original text if not already saved
         if (!button.getAttribute('data-original-text')) {
           button.setAttribute('data-original-text', originalText);
         }
         
         // Create spinner HTML
         const spinnerHTML = '<span class="loading-spinner-inline"></span> ' + loadingText;
         button.innerHTML = spinnerHTML;
         button.disabled = true;
         button.classList.add('button-loading');
       } else {
         // Restore original text and state
         button.innerHTML = originalText;
         button.disabled = false;
         button.classList.remove('button-loading');
       }
     }
     
     // --- Helper function to show alerts ---
     function showAlert(message, type = 'info') {
       // Create alert element if it doesn't exist
       let alertElement = document.getElementById('global-alert');
       if (!alertElement) {
         alertElement = document.createElement('div');
         alertElement.id = 'global-alert';
         alertElement.style.position = 'fixed';
         alertElement.style.bottom = '20px';
         alertElement.style.right = '20px';
         alertElement.style.padding = '10px 15px';
         alertElement.style.borderRadius = '4px';
         alertElement.style.zIndex = '9999';
         alertElement.style.maxWidth = '300px';
         alertElement.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
         document.body.appendChild(alertElement);
       }
       
       // Set styles based on alert type
       switch (type) {
         case 'success':
           alertElement.style.backgroundColor = 'var(--success-color, #34d399)';
           alertElement.style.color = '#fff';
           break;
         case 'warning':
           alertElement.style.backgroundColor = 'var(--warning-color, #fbbf24)';
           alertElement.style.color = '#fff';
           break;
         case 'error':
           alertElement.style.backgroundColor = 'var(--error-color, #f87171)';
           alertElement.style.color = '#fff';
           break;
         default: // info
           alertElement.style.backgroundColor = 'var(--accent, #a78bfa)';
           alertElement.style.color = '#fff';
       }
       
       // Set message and show alert
       alertElement.textContent = message;
       alertElement.style.display = 'block';
       
       // Hide alert after 3 seconds
       setTimeout(() => {
         alertElement.style.display = 'none';
       }, 3000);
     }
     
     // --- Configuration (Ensure these match your setup) ---
     const SUPABASE_URL = "https://mjwjxxfnqbaroxwjewms.supabase.co"; // Your Supabase URL
     const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1qd2p4eGZucWJhcm94d2pld21zIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQzNDg1NDQsImV4cCI6MjA1OTkyNDU0NH0.dYc-6m6gjpWlCD-qXYP5q_biO0Ai_CdpZMsPcPfD6Vk"; // Your Supabase Anon Key
     const BACKEND_URL = "https://ai-thumbnail-maker.onrender.com"; // DEV: Your Local Flask backend URL
     const STRIPE_PUBLISHABLE_KEY = "pk_live_51RGO3VFj9LYfI1R0cQJetymluTuFJypOZ50kEaYzTNuyldVzHAp44DzqZWasbk5mBd2Rw0x5dXW4zAJxnPsP7SKK00aGiig0wu"; // Your Stripe Publishable Key

     // --- Development/Debug Flags ---
     const USE_PLACEHOLDER_PREVIEWS = false; // Set to false for production/live API calls
     const PLACEHOLDER_PREVIEW_DATA = {
         images: [
             "images/ggg.jpg",
             "images/ggg.jpg",
             "images/gg.png",
             "images/ggg.jpg",
             "images/ggg.jpg",
             "images/ggg.jpg"
         ],
         prompts: [
             "Placeholder prompt 1: A majestic lion in the savanna.",
             "Placeholder prompt 2: A futuristic robot exploring Mars.",
             "Placeholder prompt 3: A cozy cabin in a snowy forest.",
             "Placeholder prompt 4: A vibrant coral reef teeming with life.",
             "Placeholder prompt 5: An abstract representation of data.",
             "Placeholder prompt 6: A delicious-looking pizza, top-down view."
         ],
         credits_remaining: 999 // Dummy credit count for development
     };

     // --- Constants ---
     const NUM_IMAGES_EXPECTED = 2;
     const CREDIT_COST_PER_IMAGE = 1;
     const TOTAL_GENERATION_COST = NUM_IMAGES_EXPECTED * CREDIT_COST_PER_IMAGE;
     const HISTORY_ITEMS_PER_PAGE = 10;
     // --- NEW Asset Extraction Constants ---
     const CREDIT_COST_PER_ASSET_EXTRACTION = 3; // Match backend
     const ASSET_HISTORY_ITEMS_PER_PAGE = 5; // Match backend default or choose your own

     // --- Initialization ---
     let stripe = null;
     try {
         if (!STRIPE_PUBLISHABLE_KEY || STRIPE_PUBLISHABLE_KEY === "YOUR_STRIPE_PUBLISHABLE_KEY") {
             throw new Error("Stripe Publishable Key is not configured.");
         }
         stripe = Stripe(STRIPE_PUBLISHABLE_KEY);
     } catch (e) {
         console.error("Stripe initialization failed:", e);
         const purchaseStatusElement = document.getElementById('purchase-status');
         if (purchaseStatusElement) {
             purchaseStatusElement.innerText = "Payment system error.";
             purchaseStatusElement.className = 'error header-purchase-status'; // Add header class
         }
         const buyButtons = document.querySelectorAll('.buy-credits-button');
         buyButtons.forEach(btn => btn.disabled = true);
     }
     const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

     // --- Global state ---
     let currentSession = null;
     let currentUserCredits = null;
     // Thumbnail History State
     let currentHistoryPage = 1;
     let totalHistoryItems = 0;
     let isLoadingHistory = false;
     // --- NEW Asset History State ---
     let currentAssetHistoryPage = 1;
     let totalAssetHistoryItems = 0;
     let isLoadingAssetHistory = false;
     let selectedAssetImageDataUri = null; // Store selected PNG data URI

     // --- DOM Element References ---
     const form = document.getElementById('thumbnailForm');
     const resultDiv = document.getElementById('result');
     const authDiv = document.getElementById('auth');
     const authStatusP = document.getElementById('auth-status');
     const mainAppContentDiv = document.getElementById('main-app-content');
     const promptGenContentDiv = document.getElementById('prompt-gen-tab-content');
     // Tabs
     const promptGenTabButton = document.getElementById('tab-prompt-gen');
     const assetExtractionTabButton = document.getElementById('tab-asset-extraction');
     const styleProfileTabButton = document.getElementById('tab-style-profile');
     // User Info Header
     const logoutButton = document.getElementById('logout-button');
     const creditsContainer = document.getElementById('credits-container');
     const creditsDisplaySpan = document.getElementById('credits-display');
     const userInfoDisplayDiv = document.getElementById('user-info-display');
     const userEmailDisplaySpan = document.getElementById('user-email-display');
     const purchaseStatusP = document.getElementById('purchase-status');
     const purchaseControlsDiv = document.querySelector('.purchase-controls');
     const userInfoContainer = document.querySelector('.user-info-container'); // Reference user info header
     // Thumbnail Generation Elements
     const generatePromptButton = document.getElementById('generate-prompt-button');
     const promptPreviewDiv = document.getElementById('prompt-preview');
     const confirmPromptButton = document.getElementById('confirm-prompt-button');
     const creditWarningP = document.getElementById('credit-warning');
     const optionsContainer = document.getElementById('prompt-options-container');
     // Thumbnail History Elements
     const historyButton = document.getElementById('history-button');
     const historyDiv = document.getElementById('history');
     const loadMoreContainer = document.getElementById('history-load-more-container');
     const loadMoreButton = document.getElementById('history-load-more-button');
     // --- NEW Asset Extraction Elements ---
     const assetExtractionContentDiv = document.getElementById('asset-extraction-content');
     const assetSourceImageInput = document.getElementById('asset-source-image');
     const assetPreviewContainer = document.getElementById('asset-preview-container');
     const assetPreviewImage = document.getElementById('asset-preview-image');
     const assetPreviewPlaceholder = document.getElementById('asset-preview-placeholder');
     const assetDescriptionInput = document.getElementById('asset-description');
     const extractAssetButton = document.getElementById('extract-asset-button');
     const assetStatusP = document.getElementById('asset-status');
     const assetResultArea = document.getElementById('asset-result-area');
     const assetResultContainer = document.getElementById('asset-result-container');
     const assetResultImage = document.getElementById('asset-result-image');
     const assetDownloadButton = document.getElementById('asset-download-button');
     // --- NEW Asset History Elements ---
     const assetHistoryButton = document.getElementById('asset-history-button');
     const assetHistoryDisplayDiv = document.getElementById('asset-history-display');
     const assetHistoryLoadMoreContainer = document.getElementById('asset-history-load-more-container');
     const assetHistoryLoadMoreButton = document.getElementById('asset-history-load-more-button');

     // --- Image Modal Close Functionality ---
     const imageModalForClose = document.getElementById('img-modal');
     if (imageModalForClose) {
        imageModalForClose.addEventListener('click', function(event) {
            // Close only if the click is on the modal backdrop itself, not on its children (e.g., the image)
            if (event.target === imageModalForClose) {
                imageModalForClose.style.display = 'none';
            }
        });
     }

     // --- NEW: Style Profile Elements ---
     const styleProfileContentDiv = document.getElementById('style-profile-content');
     const styleThumbnailsUpload = document.getElementById('style-thumbnails-upload');
     const thumbnailPreviewsDiv = document.getElementById('thumbnail-previews');
     const analyzeStyleButton = document.getElementById('analyze-style-button');
     const styleAnalysisStatus = document.getElementById('style-analysis-status');
     const styleProfileResult = document.getElementById('style-profile-result');
     const styleProfileJson = document.getElementById('style-profile-json');
     const styleNameInput = document.getElementById('style-name');
     const saveStyleButton = document.getElementById('save-style-button');
     const savedStylesList = document.getElementById('saved-styles-list');
     const noSavedStylesMessage = document.getElementById('no-saved-styles-message');

     // --- NEW: Sub-tab functionality for Image Generation ---
     const subTabPrecisionButton = document.getElementById('sub-tab-precision');
     const subTabQuickButton = document.getElementById('sub-tab-quick');
     const precisionModeContent = document.getElementById('precision-mode-content');
     const quickModeContent = document.getElementById('quick-mode-content');

     if (subTabPrecisionButton && subTabQuickButton && precisionModeContent && quickModeContent) {
         subTabPrecisionButton.addEventListener('click', () => {
             if (!subTabPrecisionButton.classList.contains('active')) {
                 subTabPrecisionButton.classList.add('active');
                 subTabQuickButton.classList.remove('active');
                 precisionModeContent.classList.add('active');
                 quickModeContent.classList.remove('active');
             }
         });

         subTabQuickButton.addEventListener('click', () => {
             if (!subTabQuickButton.classList.contains('active')) {
                 subTabQuickButton.classList.add('active');
                 subTabPrecisionButton.classList.remove('active');
                 quickModeContent.classList.add('active');
                 precisionModeContent.classList.remove('active');
             }
         });
     }
     // --- End of Sub-tab functionality ---

     // --- NEW: Precision Mode Step 1 Functionality ---
     const videoTopicInput = document.getElementById('video-topic-input');
     const submitVideoTopicButton = document.getElementById('submit-video-topic');
     const precisionStep1Status = document.getElementById('precision-step1-status');
     const precisionStep1VideoTopic = document.getElementById('precision-step1-video-topic'); // Define the missing constant
     const precisionPreviewsContainer = document.getElementById('precision-previews-container');
     const precisionPreviewsGrid = document.getElementById('precision-previews-grid');
     const precisionPreviewsStatus = document.getElementById('precision-previews-status');
     const regeneratePreviewsButton = document.getElementById('regenerate-previews-button');

     let currentPrecisionVideoTopic = ''; // To store the topic for regeneration

     // --- Refactored function to generate precision previews ---
     async function generateAndDisplayPrecisionPreviews(videoTopic, statusElement, triggerButton, isRefinement = false, isRefinedPrompt = false) {
        console.log(`🔍 generateAndDisplayPrecisionPreviews called with:
            videoTopic: ${videoTopic}
            isRefinement: ${isRefinement}
            isRefinedPrompt: ${isRefinedPrompt}
            triggerButton: ${triggerButton ? triggerButton.id : 'undefined'}
            caller: ${new Error().stack.split('\n')[2]}`);
        if (!videoTopic) {
            statusElement.textContent = 'Video topic is missing.';
            statusElement.className = 'error';
            return;
        }
        
        // If this is a refinement request, update the current topic
        if (isRefinement) {
            currentPrecisionVideoTopic = videoTopic;
        }

        // --- Development: Use Placeholder Previews ---
        if (typeof USE_PLACEHOLDER_PREVIEWS !== 'undefined' && USE_PLACEHOLDER_PREVIEWS) {
            console.log('DEV MODE: Using placeholder previews.');
            const originalButtonTextForPlaceholder = triggerButton.innerHTML;
            triggerButton.innerHTML = `<span class="loading-spinner" style="display: inline-block;"></span> Loading Placeholders...`;
            triggerButton.disabled = true;
            if (triggerButton === regeneratePreviewsButton && submitVideoTopicButton) submitVideoTopicButton.disabled = true;
            else if (triggerButton === submitVideoTopicButton && regeneratePreviewsButton) regeneratePreviewsButton.style.display = 'none';

            precisionPreviewsGrid.innerHTML = ''; // Clear existing previews
            statusElement.innerHTML = '<span class="loading-spinner"></span> Loading placeholder previews...';
            statusElement.className = 'info';
            
            // Hide the video topic input container and show previews
            if (precisionStep1VideoTopic) precisionStep1VideoTopic.style.display = 'none';
            precisionPreviewsContainer.style.display = 'block';

            setTimeout(() => {
                PLACEHOLDER_PREVIEW_DATA.images.forEach((imgUrl, index) => {
                    const previewCell = document.createElement('div');
                    previewCell.className = 'preview-cell';
                    previewCell.style.textAlign = 'center';
                    const imgElement = document.createElement('img');
                    imgElement.src = imgUrl;
                    imgElement.alt = `Placeholder Preview ${index + 1}`;
                    imgElement.style.maxWidth = '100%';
                    imgElement.style.borderRadius = 'var(--radius)';
                    imgElement.style.border = '1px solid var(--border-color)';
                    imgElement.style.marginBottom = '0.5rem';
                    imgElement.addEventListener('click', () => {
                        const modal = document.getElementById('img-modal');
                        const modalImg = modal.querySelector('img');
                        modalImg.src = imgUrl;
                        modal.style.display = 'flex';
                    });

                    const buttonsDiv = document.createElement('div');
                    buttonsDiv.className = 'preview-actions-container';
                    buttonsDiv.innerHTML = `
                        <button class="precision-use-button" data-index="${index}" data-prompt="${PLACEHOLDER_PREVIEW_DATA.prompts[index]}" style="margin-right: 0.5rem;">Use</button>
                        <button class="precision-edit-button" data-index="${index}" data-prompt="${PLACEHOLDER_PREVIEW_DATA.prompts[index]}">Edit</button>
                    `;
                    previewCell.appendChild(imgElement);
                    previewCell.appendChild(buttonsDiv);
                    precisionPreviewsGrid.appendChild(previewCell);
                });

                statusElement.textContent = 'Placeholder previews loaded! (Dev Mode)';
                statusElement.className = 'success';
                if (creditsDisplaySpan) {
                    creditsDisplaySpan.textContent = PLACEHOLDER_PREVIEW_DATA.credits_remaining;
                }
                if (regeneratePreviewsButton) regeneratePreviewsButton.style.display = 'block';
                
                triggerButton.disabled = false;
                triggerButton.innerHTML = originalButtonTextForPlaceholder;
                if (triggerButton === regeneratePreviewsButton && submitVideoTopicButton) submitVideoTopicButton.disabled = false;
                
                // Store the topic for potential real regeneration if user turns off dev mode later
                currentPrecisionVideoTopic = videoTopic; 
                // Don't set textContent as it will show when hidden

            }, 750); // Simulate network delay for placeholders
            return; // IMPORTANT: Exit function to prevent real API call
        }
        // --- End of Development Placeholder Logic ---

        if (currentUserCredits === null || currentUserCredits < 1) {
            statusElement.textContent = 'Not enough credits. Please buy more.';
            statusElement.className = 'error';
            showAlert('You do not have enough credits for this action. Please purchase more credits.', 'error');
            return;
        }

        const originalButtonText = triggerButton.innerHTML;
        // Directly set the loading HTML for the trigger button
        triggerButton.innerHTML = `<span class="loading-spinner" style="display: inline-block;"></span> Generating...`;
        triggerButton.disabled = true;

        // Clear previous previews and set specific loading states based on the trigger
        if (triggerButton === regeneratePreviewsButton) {
            precisionPreviewsGrid.innerHTML = ''; // Clear old grid
            if (submitVideoTopicButton) submitVideoTopicButton.disabled = true;
                
                // Create loading animation container
                const loadingContainer = document.createElement('div');
                loadingContainer.id = 'preview-loading-container';
                loadingContainer.style.textAlign = 'center';
                loadingContainer.style.padding = '2rem';
                loadingContainer.style.marginTop = '1rem';
                loadingContainer.innerHTML = `
                    <div style="margin-bottom: 1rem;">
                        <span class="loading-spinner" style="width: 40px; height: 40px; margin-bottom: 1rem;"></span>
                        <div id="preview-loading-text" style="font-size: 1.1rem; margin-top: 1rem;">Generating preview 1/6...</div>
                    </div>
                    <div style="width: 100%; max-width: 300px; height: 10px; background-color: var(--bg-secondary); border-radius: 5px; margin: 0 auto; overflow: hidden;">
                        <div id="preview-loading-bar" style="width: 16.6%; height: 100%; background-color: var(--accent); transition: width 0.5s ease-in-out;"></div>
                    </div>
                `;
            
            // Ensure the container holding the regenerate button and its status is visible
            precisionPreviewsContainer.style.display = 'block'; 
                precisionPreviewsGrid.appendChild(loadingContainer);
                statusElement.innerHTML = 'Regenerating ideas & previews...';
            statusElement.className = 'info';
                
                // Start the progress animation
                startPreviewLoadingAnimation();
        } else { // triggerButton === submitVideoTopicButton
            precisionPreviewsGrid.innerHTML = ''; // Clear grid just in case
                
                // Create loading animation container
                const loadingContainer = document.createElement('div');
                loadingContainer.id = 'preview-loading-container';
                loadingContainer.style.textAlign = 'center';
                loadingContainer.style.padding = '2rem';
                loadingContainer.style.marginTop = '1rem';
                loadingContainer.innerHTML = `
                    <div style="margin-bottom: 1rem;">
                        <span class="loading-spinner" style="width: 40px; height: 40px; margin-bottom: 1rem;"></span>
                        <div id="preview-loading-text" style="font-size: 1.1rem; margin-top: 1rem;">Generating preview 1/6...</div>
                    </div>
                    <div style="width: 100%; max-width: 300px; height: 10px; background-color: var(--bg-secondary); border-radius: 5px; margin: 0 auto; overflow: hidden;">
                        <div id="preview-loading-bar" style="width: 16.6%; height: 100%; background-color: var(--accent); transition: width 0.5s ease-in-out;"></div>
                    </div>
                `;
                
                // Hide the video topic input container and show the loading animation
                if (precisionStep1VideoTopic) precisionStep1VideoTopic.style.display = 'none';
                precisionPreviewsContainer.style.display = 'block';
                precisionPreviewsGrid.appendChild(loadingContainer);
                
            if (regeneratePreviewsButton) regeneratePreviewsButton.style.display = 'none';
                statusElement.innerHTML = 'Generating ideas & previews...';
            statusElement.className = 'info';
                
                // Start the progress animation
                startPreviewLoadingAnimation();
        }
        // Note: The triggerButton itself is already disabled and its text/spinner updated earlier

        try {
            const token = currentSession?.access_token;
            if (!token) {
                showAlert('Authentication error. Please log in again.', 'error');
                statusElement.textContent = 'Authentication error.';
                statusElement.className = 'error';
                return;
            }

            const response = await fetch(`${BACKEND_URL}/api/precision/generate-previews`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                    body: JSON.stringify({ 
                        video_topic: videoTopic,
                        is_refined_prompt: isRefinedPrompt // Pass the flag to indicate if this is a refined prompt
                    })
            });

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error || `HTTP error! status: ${response.status}`);
            }
            
            // Check if this was a duplicate request that was skipped by the backend
            if (data.skipped_duplicate) {
                console.log('Backend detected and skipped a duplicate request. No action needed.');
                return; // Exit early without updating UI
            }

            // Remove the loading container
            const loadingContainer = document.getElementById('preview-loading-container');
            if (loadingContainer) {
                loadingContainer.remove();
            }

            if (data.images && data.images.length > 0) {
                // Keep the video topic input hidden and show the previews
                if (precisionStep1VideoTopic) precisionStep1VideoTopic.style.display = 'none';
                precisionPreviewsContainer.style.display = 'block';
                data.images.forEach((imgUrl, index) => {
                    const previewCell = document.createElement('div');
                    previewCell.className = 'preview-cell';
                    previewCell.style.textAlign = 'center';
                    const imgElement = document.createElement('img');
                    imgElement.src = imgUrl;
                    imgElement.alt = `Preview ${index + 1}`;
                    imgElement.style.maxWidth = '100%';
                    imgElement.style.borderRadius = 'var(--radius)';
                    imgElement.style.border = '1px solid var(--border-color)';
                    imgElement.style.marginBottom = '0.5rem';
                    imgElement.addEventListener('click', () => {
                        const modal = document.getElementById('img-modal');
                        const modalImg = modal.querySelector('img');
                        modalImg.src = imgUrl;
                        modal.style.display = 'flex';
                    });

                    const buttonsDiv = document.createElement('div');
                    buttonsDiv.className = 'preview-actions-container';
                    buttonsDiv.innerHTML = `
                        <button class="precision-use-button" data-index="${index}" data-prompt="${data.prompts[index]}" style="margin-right: 0.5rem;">Use</button>
                        <button class="precision-edit-button" data-index="${index}" data-prompt="${data.prompts[index]}">Edit</button>
                    `;
                    previewCell.appendChild(imgElement);
                    previewCell.appendChild(buttonsDiv);
                    precisionPreviewsGrid.appendChild(previewCell);
                });
                if (isRefinement) {
                    statusElement.textContent = 'Refined previews generated! Choose one to use or refine further.';
                } else {
                statusElement.textContent = 'Previews generated! Choose one to refine or regenerate.';
                }
                statusElement.className = 'success';
                currentUserCredits = data.credits_remaining;
                if (creditsDisplaySpan) {
                    creditsDisplaySpan.textContent = currentUserCredits;
                }
                if (regeneratePreviewsButton) regeneratePreviewsButton.style.display = 'block'; // Show regenerate button
            } else {
                statusElement.textContent = 'No previews were generated. Please try again.';
                precisionPreviewsContainer.style.display = 'block'; // Show container to display status
                if (regeneratePreviewsButton) regeneratePreviewsButton.style.display = 'block'; // Still show regenerate button
            }

        } catch (error) {
            console.error('Error generating precision previews:', error);
            
            // Remove the loading container
            const loadingContainer = document.getElementById('preview-loading-container');
            if (loadingContainer) {
                loadingContainer.remove();
            }
            
            statusElement.textContent = `Error: ${error.message}`;
            statusElement.className = 'error';
            showAlert(`Failed to generate previews: ${error.message}`, 'error');
            if (regeneratePreviewsButton) regeneratePreviewsButton.style.display = 'block'; // Show regenerate button even on error
        } finally {
            triggerButton.disabled = false;
            triggerButton.innerHTML = originalButtonText; // Restore original button text/content
            if (buttonSpinner) buttonSpinner.style.display = 'none';

            // Re-enable the other button if it was disabled
            if (triggerButton === regeneratePreviewsButton && submitVideoTopicButton) {
                submitVideoTopicButton.disabled = false;
            }
            // The statusElement (either precisionStep1Status or precisionPreviewsStatus) 
            // has already been updated by the try/catch block with success or error messages.
            // No further clearing logic is strictly needed here for precisionPreviewsStatus based on which statusElement was used.
        }
    }

     const newThumbnailButton = document.getElementById('new-thumbnail-button');
     
     if (newThumbnailButton && precisionStep1VideoTopic && precisionPreviewsContainer) {
         newThumbnailButton.addEventListener('click', () => {
            // Show the video topic input and hide the previews
            precisionStep1VideoTopic.style.display = 'block';
            precisionPreviewsContainer.style.display = 'none';
            
            // Clear the input field and status
            if (videoTopicInput) videoTopicInput.value = '';
            if (precisionStep1Status) precisionStep1Status.textContent = '';
         });
    }

     if (submitVideoTopicButton && videoTopicInput && precisionStep1Status && precisionPreviewsContainer && precisionPreviewsGrid && precisionPreviewsStatus && regeneratePreviewsButton) {
         submitVideoTopicButton.addEventListener('click', async () => {
            const topic = videoTopicInput.value.trim();
            if (!topic) {
                precisionStep1Status.textContent = 'Please enter what your video is about.';
                precisionStep1Status.className = 'error';
                return;
            }
            currentPrecisionVideoTopic = topic; // Store the topic
            
            // Store the topic but clear the input field (which would otherwise show behind previews)
            const storedTopic = topic;
            videoTopicInput.value = '';
            
            await generateAndDisplayPrecisionPreviews(storedTopic, precisionStep1Status, submitVideoTopicButton);
         });

         regeneratePreviewsButton.addEventListener('click', async () => {
            if (!currentPrecisionVideoTopic) {
                precisionPreviewsStatus.textContent = 'No video topic found to regenerate. Please submit a topic first.';
                precisionPreviewsStatus.className = 'error';
                return;
            }
            // Use precisionPreviewsStatus for messages from the regenerate button
            await generateAndDisplayPrecisionPreviews(currentPrecisionVideoTopic, precisionPreviewsStatus, regeneratePreviewsButton);
         });
     }
     // --- End of Precision Mode Step 1 Functionality ---


     // --- NEW: Precision Mode "Use" Flow Functionality ---
     const precisionUseFlowContainer = document.getElementById('precision-use-flow-container');
     const enlargedPreviewImage = document.getElementById('enlarged-preview-image');
     const precisionHQStatus = document.getElementById('precision-hq-status');
     const backToPreviewsButton = document.getElementById('back-to-previews-button');

      // New Canvas Text Editor Elements
      const textEditorCanvas = document.getElementById('image-text-canvas'); // Corrected ID
      let ctx = textEditorCanvas ? textEditorCanvas.getContext('2d') : null; // Initialize ctx if canvas is found
      const captionTextInput = document.getElementById('caption-input'); // Corrected ID
      // const fontSelect = document.getElementById('font-select'); // Removed, replaced by font-button-container
      const fontButtonContainer = document.getElementById('font-button-container');
      const fontSizeInput = document.getElementById('font-size-input');
      const textColorPicker = document.getElementById('text-color-picker');
      // Apply text button removed - text is automatically applied
// const applyTextButton = document.getElementById('apply-text-button');
      const addTextObjectButton = document.getElementById('add-text-object-button');
      const textInputDetailsContainer = document.getElementById('text-input-details-container');
      const finalImageActionsContainer = document.getElementById('final-image-actions-container');
      const downloadFinalImageButton = document.getElementById('download-final-image-button');
      const upscaleFinalImageButton = document.getElementById('upscale-final-image-button');
     
     let currentSelectedPromptForHQ = '';
     let currentSelectedImageUrlForHQ = '';
     let loadedBaseImageForCanvas = null; // To store the Image object for canvas
     let originalPreviewImageUrl = ''; // To store the original preview image URL before upscaling
     let originalTextObjects = []; // To store the original text objects before upscaling
     // These variables are no longer used - we use the multi-text object approach now
     // let textX, textY; 
     // let isDragging = false;
     let dragOffsetX = 0, dragOffsetY = 0;

      // State for new UI flow
      let isTextAppliedToPreview = false;
      let appliedTextParameters = null;
      // Text editing is never locked in this version
let isTextEditingLocked = false; // Keeping variable but not using it

      // State for multiple text objects
      let textObjects = []; // Array to hold all text objects on the canvas
      let selectedTextObjectIndex = -1; // -1 means no object is selected
      let nextTextObjectId = 0; // Simple incrementing ID for new objects



      // State for dragging text objects
      let isTextObjectDragging = false;
      let textObjectDragStartX, textObjectDragStartY; // Mouse position when drag starts
      let selectedObjectStartX, selectedObjectStartY; // Selected text object's position when drag starts
      // dragOffsetX and dragOffsetY are already declared above
      // Removed redeclared loadedBaseImageForCanvas, currentPreviewImageUrlForCanvas, currentPreviewBasePrompt
      // Their primary declarations are above (around line 1952)

      let selectedFontFamilyForCSS = 'Arial'; // Default, will be updated by generateFontUI
      let selectedFontFilenameForBackend = 'arial.ttf'; // Default, will be updated
      const availableFontFiles = [
        "AlfaSlabOne-Regular.ttf", "AlumniSansSC-VariableFont_wght.ttf", "LibreFranklin-VariableFont_wght.ttf", 
        "LuckiestGuy-Regular.ttf", "Outfit-Black.ttf", "Outfit-Bold.ttf", "Outfit-ExtraBold.ttf", 
        "Outfit-ExtraLight.ttf", "Outfit-Light.ttf", "Outfit-Medium.ttf", "Outfit-Regular.ttf", 
        "Outfit-SemiBold.ttf", "Outfit-Thin.ttf", "Pacifico-Regular.ttf", "Quantico-Bold.ttf", 
        "Quantico-Regular.ttf"
      ];

      function getFontFamilyNameFromFilename(filename) {
          let name = filename.substring(0, filename.lastIndexOf('.')); // Remove extension
          name = name.replace(/-/g, ' '); // Replace hyphens with spaces
          name = name.replace(/VariableFont_wght/ig, '').trim(); // Remove VariableFont_wght case-insensitively
          name = name.replace(/SC/g, ' SC'); // Add space before SC for AlumniSansSC, etc.
          // Simple title case
          name = name.split(' ').map(word => word.charAt(0).toUpperCase() + word.substring(1).toLowerCase()).join(' ');          
          return name.replace(/\s+/g, ' ').trim(); // Normalize spaces
      }

      // Global variable to store the working font path
      let globalFontPath = './public/fonts/'; // Default path - relative to frontend/app/
      
      // Function to determine the correct font path
      function determineFontPath() {
          // Possible paths to try
          const possiblePaths = [
              '/public/fonts/', // Absolute path from root
              './public/fonts/', // Relative to current directory
              '../public/fonts/', // One directory up
              '/fonts/', // Direct in root
              './fonts/', // In current directory
              '../../fonts/' // Two directories up (original path)
          ];
          
          console.log('Using font path:', globalFontPath);
          
          // Return the current global path
          return globalFontPath;
      }
      
      // Function to check if a path works and update the global path
      async function checkAndUpdateFontPath() {
          const possiblePaths = [
              '/public/fonts/', // Absolute path from root
              './public/fonts/', // Relative to current directory
              '../public/fonts/', // One directory up
              '/fonts/', // Direct in root
              './fonts/', // In current directory
              '../../fonts/' // Two directories up (original path)
          ];
          
          // Test font to check
          const testFont = 'AlfaSlabOne-Regular.ttf';
          
          // Try each path
          for (const path of possiblePaths) {
              try {
                  const response = await fetch(path + testFont, { method: 'HEAD' });
                  if (response.ok) {
                      console.log(`Found working font path: ${path}`);
                      globalFontPath = path;
                      return path;
                  }
              } catch (error) {
                  console.log(`Path ${path} failed:`, error);
              }
          }
          
          console.log('No working font path found, using default');
          return globalFontPath; // Return default if none work
      }
      
      // Debug function to check if fonts are loading correctly
      function debugFontLoading() {
          console.log('Debugging font loading...');
          console.log(`Current global font path: ${globalFontPath}`);
          
          // Check if our test font loads with the current path
          const testFont = 'AlfaSlabOne-Regular.ttf';
          const fullPath = `${globalFontPath}${testFont}`;
          
          fetch(fullPath)
              .then(response => {
                  if (response.ok) {
                      console.log(`✅ Font loads successfully from: ${fullPath}`);
                  } else {
                      console.error(`❌ Font failed to load from: ${fullPath}`);
                  }
              })
              .catch(error => {
                  console.error(`❌ Error loading font from ${fullPath}:`, error);
              });
      }

      function generateFontUI() {
          if (!fontButtonContainer) return;
          fontButtonContainer.innerHTML = ''; // Clear existing buttons
          const styleSheet = document.getElementById('dynamic-font-styles');
          if (styleSheet) styleSheet.innerHTML = ''; // Clear existing @font-face rules

          // Find AlfaSlabOne-Regular.ttf in availableFontFiles for default font
          const defaultFontIndex = availableFontFiles.findIndex(filename => 
              filename === "AlfaSlabOne-Regular.ttf"
          );
          
          // If AlfaSlabOne not found, use the first font as default
          const defaultIndex = defaultFontIndex !== -1 ? defaultFontIndex : 0;

          availableFontFiles.forEach((filename, index) => {
              const fontFamilyForCSS = getFontFamilyNameFromFilename(filename);
              if (!fontFamilyForCSS) return; // Skip if name generation fails

              // Add @font-face rule
              // Use the global font path with fallbacks for better compatibility
              const fontFaceRule = `@font-face { 
                font-family: '${fontFamilyForCSS}'; 
                src: url('${globalFontPath}${filename}');
              }\n`;
              if (styleSheet) styleSheet.appendChild(document.createTextNode(fontFaceRule));

              const button = document.createElement('button');
              button.className = 'font-button';
              button.dataset.fontFamilyCss = fontFamilyForCSS;
              button.dataset.fontFilenameBackend = filename;
              button.style.fontFamily = `'${fontFamilyForCSS}', var(--font-fallback, sans-serif)`;
              button.textContent = fontFamilyForCSS; // Display the derived name

              if (index === defaultIndex && availableFontFiles.length > 0) { // Set AlfaSlabOne as default active
                  selectedFontFamilyForCSS = fontFamilyForCSS;
                  selectedFontFilenameForBackend = filename;
                  button.classList.add('active');
              } else if (availableFontFiles.length === 0) { // Fallback if no fonts
                  selectedFontFamilyForCSS = 'Arial';
                  selectedFontFilenameForBackend = 'arial.ttf';
              }

              button.addEventListener('click', () => {
                  const clickedFontFamily = button.dataset.fontFamilyCss;
                  const clickedFontFilename = button.dataset.fontFilenameBackend;

                  if (selectedTextObjectIndex !== -1 && textObjects[selectedTextObjectIndex]) {
                      textObjects[selectedTextObjectIndex].fontFamily = clickedFontFamily;
                      textObjects[selectedTextObjectIndex].fontFilename = clickedFontFilename;
                      
                      selectedFontFamilyForCSS = clickedFontFamily; // Keep global defaults updated
                      selectedFontFilenameForBackend = clickedFontFilename;

                      updateControlsForSelectedText(); // Syncs UI including active button
                      drawCanvas();
                  } else {
                      // No text object selected, just update global defaults and active button for next new text
                      selectedFontFamilyForCSS = clickedFontFamily;
                      selectedFontFilenameForBackend = clickedFontFilename;

                      const currentActive = fontButtonContainer.querySelector('.font-button.active');
                      if (currentActive) currentActive.classList.remove('active');
                      button.classList.add('active');
                      // drawCanvas(); // Only needed if there's a default display that uses global font
                  }
              });
              fontButtonContainer.appendChild(button);
          });
          // Initial draw with the default/first font if canvas is ready
          if (ctx && loadedBaseImageForCanvas) {
             drawCanvas(); 
          }
      }

      function initializeCanvasEditor(imageUrl, basePrompt) {
        // generateFontUI() is called on DOMContentLoaded, so font buttons should be ready.
        // However, we might want to ensure the default font is correctly applied if the editor is re-initialized.
        if (fontButtonContainer && fontButtonContainer.firstChild && !fontButtonContainer.querySelector('.font-button.active')){
            // Try to find AlfaSlabOne button first
            const alfaSlabOneButton = Array.from(fontButtonContainer.querySelectorAll('.font-button'))
                .find(btn => btn.dataset.fontFilenameBackend === "AlfaSlabOne-Regular.ttf");
            
            if(alfaSlabOneButton){
                alfaSlabOneButton.click(); // Simulate click to set AlfaSlabOne as active
            } else {
            const firstButton = fontButtonContainer.querySelector('.font-button');
            if(firstButton){
                firstButton.click(); // Simulate click to set active and draw
            } else if (availableFontFiles.length > 0) {
                    // Find AlfaSlabOne if available
                    const defaultFontIndex = availableFontFiles.findIndex(filename => 
                        filename === "AlfaSlabOne-Regular.ttf"
                    );
                    const defaultIndex = defaultFontIndex !== -1 ? defaultFontIndex : 0;
                    
                    selectedFontFamilyForCSS = getFontFamilyNameFromFilename(availableFontFiles[defaultIndex]);
                    selectedFontFilenameForBackend = availableFontFiles[defaultIndex];
            } else {
                 selectedFontFamilyForCSS = 'Arial';
                 selectedFontFilenameForBackend = 'arial.ttf';
                }
            }
        } else if (availableFontFiles.length === 0) { // Ensure defaults if no fonts
            selectedFontFamilyForCSS = 'Arial';
            selectedFontFilenameForBackend = 'arial.ttf';
        }

        currentPreviewImageUrlForCanvas = imageUrl;
        currentPreviewBasePrompt = basePrompt;
        
        // Always show the download/upscale buttons
        if (finalImageActionsContainer) finalImageActionsContainer.style.display = 'flex';
      }

     if (precisionPreviewsGrid) {

        precisionPreviewsGrid.addEventListener('click', function(event) {
            console.log('precisionPreviewsGrid clicked. Event target:', event.target);
            const useButton = event.target.closest('.precision-use-button');
            const editButton = event.target.closest('.precision-edit-button');
            console.log('Attempted to find .precision-use-button. Result:', useButton);
            
            if (useButton) {
                // Hide the upscaled image container if it exists
                const upscaledContainer = document.getElementById('upscaled-image-container');
                if (upscaledContainer) {
                    upscaledContainer.style.display = 'none';
                }
                
                // Reset text objects array and selection
                textObjects = [];
                selectedTextObjectIndex = -1;
                
                currentSelectedPromptForHQ = useButton.dataset.prompt;
                // Find the image sibling to the button's container or parent cell
                const previewCell = useButton.closest('.preview-cell');
                if (previewCell) {
                    const imgElement = previewCell.querySelector('img');
                    if (imgElement) {
                        currentSelectedImageUrlForHQ = imgElement.src;
                        // enlargedPreviewImage.src = currentSelectedImageUrlForHQ; // No longer needed, canvas handles it
                        enlargedPreviewImage.style.display = 'none'; // Hide static image preview
                        
                        const canvasEditorArea = document.getElementById('canvas-editor-area');
                        if (canvasEditorArea) {
                            canvasEditorArea.style.display = 'block'; // Show the whole canvas editor section
                        }
                        
                        // Make sure text controls are visible
                        const textControlsContainer = document.getElementById('text-controls-container');
                        const textInputDetailsContainer = document.getElementById('text-input-details-container');
                        
                        if (textControlsContainer) {
                            textControlsContainer.style.display = 'block';
                        }
                        
                        if (textInputDetailsContainer) {
                            textInputDetailsContainer.style.display = 'flex';
                        }
                        
                        // textEditorCanvas.style.display = 'block'; // Canvas is inside canvasEditorArea, will be visible if area is block

                        // Reset input fields
                        captionTextInput.value = '';
                        // fontSelect.value = 'Arial'; // Default font
                        fontSizeInput.value = '50'; // Default font size

                        loadedBaseImageForCanvas = new Image();
                        loadedBaseImageForCanvas.crossOrigin = "anonymous"; // Handle potential CORS issues with images
                        loadedBaseImageForCanvas.onload = () => {
                            if (!ctx && textEditorCanvas) ctx = textEditorCanvas.getContext('2d'); // Ensure ctx is initialized
                            if (textEditorCanvas && loadedBaseImageForCanvas) {
                                textEditorCanvas.width = loadedBaseImageForCanvas.naturalWidth;
                                textEditorCanvas.height = loadedBaseImageForCanvas.naturalHeight;
                                
                                // Text positions are now handled by the textObjects array
                                
                                drawCanvas(); // Draw image and then text with initial position
                            } else {
                                console.error('Canvas or loaded image is not available for drawing.');
                                precisionHQStatus.textContent = 'Error: Could not prepare image editor.';
                                precisionHQStatus.className = 'error';
                            }
                        };
                        loadedBaseImageForCanvas.onerror = () => {
                            console.error('Error loading image onto canvas:', currentSelectedImageUrlForHQ);
                            precisionHQStatus.textContent = 'Error: Could not load preview image for editing.';
                            precisionHQStatus.className = 'error';
                            if (canvasEditorArea) canvasEditorArea.style.display = 'none';
                            // Optionally, re-show the static preview if canvas loading fails
                            // if (enlargedPreviewImage) {
                            //     enlargedPreviewImage.src = currentSelectedImageUrlForHQ;
                            //     enlargedPreviewImage.style.display = 'block';
                            // }
                        };
                        loadedBaseImageForCanvas.src = currentSelectedImageUrlForHQ; // Assign src to trigger load
                        initializeCanvasEditor(currentSelectedImageUrlForHQ, currentSelectedPromptForHQ);
                    } else {
                        console.error('Image element (img) not found in preview cell.');
                        precisionHQStatus.textContent = 'Error: Could not find preview image to edit.';
                        precisionHQStatus.className = 'error';
                    }
                } else {
                    console.error('Preview cell (.preview-cell) not found for the clicked button.');
                    precisionHQStatus.textContent = 'Error: UI structure error.';
                    precisionHQStatus.className = 'error';
                }

                // This UI update logic should happen if 'useButton' was clicked, 
                // regardless of whether the image loading for canvas was successful.
                // Hide main generation UI, show 'Use' flow UI
                if (precisionStep1VideoTopic) {
                    precisionStep1VideoTopic.style.display = 'none';
                    // Clear the video topic input when hiding
                    const videoTopicInput = document.getElementById('video-topic-input');
                    if (videoTopicInput) videoTopicInput.value = '';
                }
                if (precisionPreviewsContainer) precisionPreviewsContainer.style.display = 'none';
                if (precisionUseFlowContainer) precisionUseFlowContainer.style.display = 'block';

                // Reset 'Use' flow state for canvas editor
                isTextAppliedToPreview = false;
                appliedTextParameters = null;
                isTextEditingLocked = false;
                if (captionTextInput) captionTextInput.disabled = false;
                if (fontButtonContainer) fontButtonContainer.disabled = false;
                if (fontSizeInput) fontSizeInput.disabled = false;
                // Make canvas interactive again if it was disabled
                // (Add logic here if canvas interaction is explicitly disabled later)

                // Apply text button removed
                if (finalImageActionsContainer) finalImageActionsContainer.style.display = 'flex'; // Show download/upscale options
                
                if (precisionHQStatus) precisionHQStatus.textContent = ''; // Clear status
                
                // Ensure canvas editor area is visible (if not already hidden by an image load error)
                // and enlarged static image is hidden.
                // The canvas itself (textEditorCanvas) visibility is handled by canvasEditorArea's display style.
                if (document.getElementById('canvas-editor-area').style.display !== 'none') {
                     if (textEditorCanvas) textEditorCanvas.style.display = 'block'; // Ensure canvas element inside is block
                }
                if (enlargedPreviewImage) enlargedPreviewImage.style.display = 'none';
            } else if (editButton) {
                // Handle edit button click
                const previewCell = editButton.closest('.preview-cell');
                if (previewCell) {
                    const imgElement = previewCell.querySelector('img');
                    const selectedPrompt = editButton.dataset.prompt;
                    const selectedIndex = editButton.dataset.index;
                    
                    if (imgElement) {
                        // Show edit modal
                        const editModal = document.getElementById('edit-modal');
                        const editPreviewImage = document.getElementById('edit-preview-image');
                        
                        if (editModal && editPreviewImage) {
                            // Store the selected prompt and image for later use
                            editModal.dataset.originalPrompt = selectedPrompt;
                            editModal.dataset.imageIndex = selectedIndex;
                            
                            // Display the image in the modal
                            editPreviewImage.src = imgElement.src;
                            editModal.style.display = 'flex';
                        }
                    }
                }
            }
        });
      }

      // --- Canvas Text Editor Logic ---
      function drawCanvas() {
        if (!ctx || !loadedBaseImageForCanvas || !loadedBaseImageForCanvas.complete) {
            console.warn('Canvas context or base image not ready for drawing.');
            return;
        }

        // Clear canvas
        ctx.clearRect(0, 0, textEditorCanvas.width, textEditorCanvas.height);

        // Draw base image
        ctx.drawImage(loadedBaseImageForCanvas, 0, 0, textEditorCanvas.width, textEditorCanvas.height);

        // Draw all text objects
        textObjects.forEach((textObj, index) => {
            if (!textObj || typeof textObj.text === 'undefined') {
                // console.warn('Skipping invalid text object:', textObj); // Optional: for debugging
                return; // Skip if object is malformed or doesn't have text
            }

            const { text, fontFamily, fontFilename, size, color, x, y, isSelected } = textObj; // Added fontFilename for completeness, though not used in drawing directly here
            const strokeColor = '#000000'; // Default stroke color
            const lineWidth = 3;      // Thicker stroke width for better visibility

            ctx.font = `${size}px "${fontFamily}"`; // Ensure font name is quoted
            ctx.fillStyle = color;
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = lineWidth;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top'; // Consistent baseline

            // Draw the text with stroke for better visibility
            ctx.strokeText(text, x, y);
            ctx.fillText(text, x, y);

            // If the text object is selected (either by its own flag or by matching selectedTextObjectIndex),
            // draw a selection indicator.
            // The isSelected flag on the object itself should be the source of truth for selection.
            if (isSelected || index === selectedTextObjectIndex) {
                ctx.save(); // Save current context state

                // Draw a more visible selection box
                const textMetrics = ctx.measureText(text);
                const textWidth = textMetrics.width;
                const textHeight = parseInt(size, 10); 
                const padding = 6; // Increased padding around the text for the selection box

                // Draw outer highlight
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; // White outer stroke
                ctx.lineWidth = 3; // Thicker line for visibility
                ctx.setLineDash([6, 3]); // Dashed line pattern
                ctx.strokeRect(
                    x - padding,
                    y - padding,
                    textWidth + (padding * 2),
                    textHeight + (padding * 2)
                );
                
                // Draw inner blue selection box
                ctx.strokeStyle = 'rgba(0, 123, 255, 0.9)'; // Brighter blue
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 3]); // Same dash pattern
                ctx.strokeRect(
                    x - padding,
                    y - padding,
                    textWidth + (padding * 2),
                    textHeight + (padding * 2)
                );
                
                // Draw selection handles at corners
                const handleSize = 8;
                ctx.fillStyle = 'rgba(0, 123, 255, 1)'; // Solid blue
                ctx.setLineDash([]); // No dash for handles
                
                // Top-left handle
                ctx.fillRect(x - padding - handleSize/2, y - padding - handleSize/2, handleSize, handleSize);
                // Top-right handle
                ctx.fillRect(x + textWidth + padding - handleSize/2, y - padding - handleSize/2, handleSize, handleSize);
                // Bottom-left handle
                ctx.fillRect(x - padding - handleSize/2, y + textHeight + padding - handleSize/2, handleSize, handleSize);
                
                // Bottom-right handle (resize handle) - make it much bigger and more visible
                const resizeHandleSize = 14; // Larger resize handle
                ctx.fillStyle = 'rgba(255, 165, 0, 1)'; // Orange for resize handle
                const cornerX = x + textWidth + padding - resizeHandleSize/2;
                const cornerY = y + textHeight + padding - resizeHandleSize/2;
                ctx.fillRect(cornerX, cornerY, resizeHandleSize, resizeHandleSize);
                
                // Add diagonal lines to indicate resize functionality
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1.5;
                
                // Draw diagonal resize icon (multiple lines for better visibility)
                // Main diagonal
                ctx.beginPath();
                ctx.moveTo(cornerX + 3, cornerY + resizeHandleSize - 3);
                ctx.lineTo(cornerX + resizeHandleSize - 3, cornerY + 3);
                ctx.stroke();
                
                // Secondary diagonals
                ctx.beginPath();
                ctx.moveTo(cornerX + 7, cornerY + resizeHandleSize - 3);
                ctx.lineTo(cornerX + resizeHandleSize - 3, cornerY + 7);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(cornerX + 3, cornerY + resizeHandleSize - 7);
                ctx.lineTo(cornerX + resizeHandleSize - 7, cornerY + 3);
                ctx.stroke();
                
                ctx.restore(); // Restore context state (line dash, stroke style, etc.)
            }
        });
      }

      // --- Helper function to find text object at a given canvas position ---
      function getTextObjectAtPosition(mouseX, mouseY) {
          if (!ctx) {
              console.error('Canvas context not available for hit testing');
              return -1; // Canvas context must be available
          }
          
          console.log('Checking if mouse position', mouseX, mouseY, 'is over any text objects');
          console.log('Current text objects:', JSON.stringify(textObjects));

          // Iterate in reverse to check top-most objects first
          for (let i = textObjects.length - 1; i >= 0; i--) {
              const textObj = textObjects[i];
              if (!textObj || typeof textObj.text === 'undefined') {
                  console.log('Skipping invalid text object at index', i);
                  continue;
              }

              // Set context for accurate measurement (font and size)
              ctx.font = `${textObj.size}px "${textObj.fontFamily}"`;
              
              const textMetrics = ctx.measureText(textObj.text);
              const textWidth = textMetrics.width;
              const textHeight = parseInt(textObj.size, 10); // Approximate height

              // Define a larger padding around the text for easier clicking
              const padding = 10; // Increased padding for easier selection
              const objLeft = textObj.x - padding;
              const objRight = textObj.x + textWidth + padding;
              const objTop = textObj.y - padding; 
              const objBottom = textObj.y + textHeight + padding;

              console.log(`Text object ${i} bounds: left=${objLeft}, right=${objRight}, top=${objTop}, bottom=${objBottom}`);

              if (mouseX >= objLeft && mouseX <= objRight && mouseY >= objTop && mouseY <= objBottom) {
                  console.log('Found text object at index', i);
                  return i; // Return index of the found object
              }
          }
          console.log('No text object found at position', mouseX, mouseY);
          return -1; // No object found at this position
      }

      function updateControlsForSelectedText() {
        const objectIsSelected = selectedTextObjectIndex !== -1 && textObjects[selectedTextObjectIndex];
        // Editing is always allowed if an object is selected (text editing is never locked)
        const allowEditing = objectIsSelected;

        // Enable/disable controls based on whether editing is allowed
        if (captionTextInput) captionTextInput.disabled = !allowEditing;
        if (fontSizeInput) fontSizeInput.disabled = !allowEditing;
        if (textColorPicker) textColorPicker.disabled = !allowEditing;
        if (fontButtonContainer) {
            fontButtonContainer.querySelectorAll('button').forEach(btn => btn.disabled = !allowEditing);
        }
        // Note: addTextObjectButton is always enabled

        if (allowEditing) {
            // An object is selected and editing is not locked: Populate controls
            const selectedObject = textObjects[selectedTextObjectIndex];
            if (captionTextInput) captionTextInput.value = selectedObject.text;
            if (fontSizeInput) fontSizeInput.value = selectedObject.size;
            if (textColorPicker) textColorPicker.value = selectedObject.color;

            // Update active font button and global font trackers
            if (fontButtonContainer) {
                const currentActiveButton = fontButtonContainer.querySelector('.font-button.active');
                if (currentActiveButton) currentActiveButton.classList.remove('active');
                
                const buttons = fontButtonContainer.querySelectorAll('.font-button');
                buttons.forEach(button => {
                    if (button.dataset.fontFamilyCss === selectedObject.fontFamily || button.dataset.fontFilenameBackend === selectedObject.fontFilename) {
                        button.classList.add('active');
                        // Sync global font selection with the currently selected text object's font
                        selectedFontFamilyForCSS = selectedObject.fontFamily;
                        selectedFontFilenameForBackend = selectedObject.fontFilename;
                    }
                });
            }
        } else {
            // No object is selected, or editing is locked: Clear caption and leave other inputs as they are or reset.
            // Controls are disabled above if allowEditing is false.
            if (captionTextInput) captionTextInput.value = '';
            // If no object is selected, the font controls (buttons) will be disabled.
            // The active font button can remain as is, so the next "Add Text" uses the last active font.
        }
      }

      if (captionTextInput) {
        captionTextInput.addEventListener('input', () => {
            if (selectedTextObjectIndex !== -1 && textObjects[selectedTextObjectIndex]) {
                textObjects[selectedTextObjectIndex].text = captionTextInput.value;
                
                // Always show the final image actions container
                        if (finalImageActionsContainer) finalImageActionsContainer.style.display = 'flex';
                
                // Immediately draw the updated text on the canvas
                drawCanvas();
                
                // Log for debugging
                console.log('Text updated:', captionTextInput.value);
            }
        });
      }
      // Event listener for old fontSelect is removed as it's replaced by font buttons with individual listeners
      if (fontSizeInput) {
        fontSizeInput.addEventListener('input', () => {
            if (selectedTextObjectIndex !== -1 && textObjects[selectedTextObjectIndex]) {
                textObjects[selectedTextObjectIndex].size = parseInt(fontSizeInput.value); // Store as number
                // updateControlsForSelectedText(); // Not strictly needed here as the input itself is the source of truth for this value
                drawCanvas();
            }
        });
      }

      if (textColorPicker) {
        textColorPicker.addEventListener('input', () => {
            if (selectedTextObjectIndex !== -1 && textObjects[selectedTextObjectIndex]) {
                textObjects[selectedTextObjectIndex].color = textColorPicker.value;
                // updateControlsForSelectedText(); // Not strictly needed here
                drawCanvas();
            }
        });
      }

      if (addTextObjectButton && textInputDetailsContainer) {
        console.log('[DEBUG] Checking addTextObjectButton listener. Has data-listener-attached:', addTextObjectButton.hasAttribute('data-listener-attached'));
        if (!addTextObjectButton.hasAttribute('data-listener-attached')) {
          addTextObjectButton.setAttribute('data-listener-attached', 'true');
          console.log('[DEBUG] Attaching click listener to addTextObjectButton NOW.');
          addTextObjectButton.addEventListener('click', () => {
            if (addTextObjectButton.getAttribute('processing-click') === 'true') {
                console.warn('[DEBUG] AddTextObjectButton click event fired while already processing a previous click. Ignoring.');
                return;
            }
            addTextObjectButton.setAttribute('processing-click', 'true');

            try {
                console.log('[DEBUG] Add New Text button CLICKED. Current textObjects.length:', textObjects.length);
                // Text editing is never locked in this version

                textInputDetailsContainer.style.display = 'flex'; // Or 'block' if flex is not desired

                const newTextObjectId = nextTextObjectId++;
                console.log(`[DEBUG] Creating newTextObject with id: ${newTextObjectId}`);
                const newTextObject = {
                    id: newTextObjectId,
                    text: 'New Text', // Default text
                    x: textEditorCanvas.width / 2 - 100, // Center horizontally (approximately)
                    y: textEditorCanvas.height / 2 - 25, // Center vertically (approximately)
                    fontFamily: selectedFontFamilyForCSS, // Use globally selected font
                    fontFilename: selectedFontFilenameForBackend, // Use globally selected font filename
                    size: parseInt(fontSizeInput.value || '50', 10),
                    color: '#FFFFFF', // Default to white for better visibility
                    isSelected: true
                };

                // Deselect any currently selected object
                if (selectedTextObjectIndex !== -1 && textObjects[selectedTextObjectIndex]) {
                    textObjects[selectedTextObjectIndex].isSelected = false;
                }
                
                console.log('[DEBUG] BEFORE push. textObjects.length:', textObjects.length);
                textObjects.push(newTextObject);
                selectedTextObjectIndex = textObjects.length - 1;
                console.log('[DEBUG] AFTER push. textObjects.length:', textObjects.length, 'Selected index:', selectedTextObjectIndex, 'Pushed ID:', newTextObject.id);
                
                updateControlsForSelectedText(); // Populate controls with new object's data and enable them
                drawCanvas(); // Draw the new text object

                if (captionTextInput) {
                    captionTextInput.focus(); // Focus on the caption input for the new text
                }
            } finally {
                addTextObjectButton.removeAttribute('processing-click');
            }
          });
        }
      }

      // Variables for resize functionality
      let isResizing = false;
      let initialTextSize = 0;
      let initialMouseY = 0;
      
      // Helper function to check if mouse is over the resize handle
      function isOverResizeHandle(mouseX, mouseY, textObj) {
          if (!ctx || !textObj) return false;
          
          // Set context for accurate measurement
          ctx.font = `${textObj.size}px "${textObj.fontFamily}"`;
          const textMetrics = ctx.measureText(textObj.text);
          const textWidth = textMetrics.width;
          const textHeight = parseInt(textObj.size, 10);
          
          const padding = 6;
          const resizeHandleSize = 14; // Match the larger size we're drawing
          
          // Bottom-right handle position
          const handleX = textObj.x + textWidth + padding - resizeHandleSize/2;
          const handleY = textObj.y + textHeight + padding - resizeHandleSize/2;
          
          // Check if mouse is over the handle (with a slightly larger hit area)
          return (
              mouseX >= handleX - 5 && 
              mouseX <= handleX + resizeHandleSize + 5 && 
              mouseY >= handleY - 5 && 
              mouseY <= handleY + resizeHandleSize + 5
          );
      }

      // --- Canvas Mouse Event Listeners for Text Object Interaction ---
      if (textEditorCanvas) {
          textEditorCanvas.addEventListener('mousedown', (e) => {
              console.log('Canvas mousedown event triggered');

              const rect = textEditorCanvas.getBoundingClientRect();
              const scaleX = textEditorCanvas.width / rect.width;
              const scaleY = textEditorCanvas.height / rect.height;
              const mouseX = (e.clientX - rect.left) * scaleX;
              const mouseY = (e.clientY - rect.top) * scaleY;

              console.log('Mouse position:', mouseX, mouseY);
              
              // First check if we're clicking on a resize handle of the selected text object
              if (selectedTextObjectIndex !== -1 && 
                  textObjects[selectedTextObjectIndex] && 
                  isOverResizeHandle(mouseX, mouseY, textObjects[selectedTextObjectIndex])) {
                  
                  console.log('Starting resize operation');
                  isResizing = true;
                  isTextObjectDragging = false;
                  initialTextSize = textObjects[selectedTextObjectIndex].size;
                  initialMouseY = mouseY;
                  textEditorCanvas.style.cursor = 'nwse-resize';
                  return;
              }

              const clickedObjectIndex = getTextObjectAtPosition(mouseX, mouseY);
              console.log('Clicked object index:', clickedObjectIndex);

              if (clickedObjectIndex !== -1) {
                  console.log('Selected text object:', textObjects[clickedObjectIndex]);
                  if (selectedTextObjectIndex !== -1 && textObjects[selectedTextObjectIndex] && selectedTextObjectIndex !== clickedObjectIndex) {
                      textObjects[selectedTextObjectIndex].isSelected = false;
                  }
                  selectedTextObjectIndex = clickedObjectIndex;
                  textObjects[selectedTextObjectIndex].isSelected = true;
                  
                  updateControlsForSelectedText();

                  isTextObjectDragging = true;
                  isResizing = false;
                  console.log('Starting drag operation');
                  
                  // Store initial mouse down position (relative to canvas)
                  textObjectDragStartX = mouseX; 
                  textObjectDragStartY = mouseY;
                  // Store initial position of the object being dragged
                  selectedObjectStartX = textObjects[selectedTextObjectIndex].x;
                  selectedObjectStartY = textObjects[selectedTextObjectIndex].y;
                  // Calculate the offset from the object's origin to the mouse click point
                  dragOffsetX = mouseX - textObjects[selectedTextObjectIndex].x;
                  dragOffsetY = mouseY - textObjects[selectedTextObjectIndex].y;
                  
                  // Change cursor to indicate dragging
                  textEditorCanvas.style.cursor = 'grabbing';
              } else {
                  if (selectedTextObjectIndex !== -1 && textObjects[selectedTextObjectIndex]) {
                      textObjects[selectedTextObjectIndex].isSelected = false;
                  }
                  selectedTextObjectIndex = -1;
                  isResizing = false;
                  updateControlsForSelectedText();
              }
              drawCanvas();
          });

          textEditorCanvas.addEventListener('mousemove', (e) => {
              if (selectedTextObjectIndex === -1) return;

              const rect = textEditorCanvas.getBoundingClientRect();
              const scaleX = textEditorCanvas.width / rect.width;
              const scaleY = textEditorCanvas.height / rect.height;
              const mouseX = (e.clientX - rect.left) * scaleX;
              const mouseY = (e.clientY - rect.top) * scaleY;

              // Handle resizing
              if (isResizing) {
                  console.log('Resizing - Mouse position:', mouseX, mouseY);
                  
                  // Calculate the vertical movement from the initial position
                  const deltaY = mouseY - initialMouseY;
                  
                  // Adjust font size based on vertical movement
                  // Moving down increases size, moving up decreases size
                  const scaleFactor = 0.5; // Adjust this to control resize sensitivity
                  const newSize = Math.max(10, initialTextSize + Math.round(deltaY * scaleFactor));
                  
                  console.log('Resizing text from', textObjects[selectedTextObjectIndex].size, 'to', newSize);
                  
                  textObjects[selectedTextObjectIndex].size = newSize;
                  
                  // Update the font size input to reflect the new size
                  if (fontSizeInput) {
                      fontSizeInput.value = newSize;
                  }

              drawCanvas();
                  return;
              }

              // Handle dragging
              if (isTextObjectDragging) {
                  console.log('Dragging - Mouse position:', mouseX, mouseY);
                  
                  // New position is current mouse position minus the initial offset
                  const newX = mouseX - dragOffsetX;
                  const newY = mouseY - dragOffsetY;
                  
                  console.log('Moving text from', textObjects[selectedTextObjectIndex].x, textObjects[selectedTextObjectIndex].y, 'to', newX, newY);
                  
                  textObjects[selectedTextObjectIndex].x = newX;
                  textObjects[selectedTextObjectIndex].y = newY;
                  
                  drawCanvas();
                  return;
              }
              
              // Update cursor based on what's under the mouse
              if (selectedTextObjectIndex !== -1 && 
                  textObjects[selectedTextObjectIndex] && 
                  isOverResizeHandle(mouseX, mouseY, textObjects[selectedTextObjectIndex])) {
                  textEditorCanvas.style.cursor = 'nwse-resize';
              } else if (getTextObjectAtPosition(mouseX, mouseY) !== -1) {
                  textEditorCanvas.style.cursor = 'grab';
              } else {
                  textEditorCanvas.style.cursor = 'default';
              }
          });

          const stopDragging = (e) => {
              // Handle end of resize operation
              if (isResizing) {
                  console.log('Stopping resize operation');
                  isResizing = false;
                  
                  // If we have event data, update cursor appropriately
                  if (e && e.clientX !== undefined && selectedTextObjectIndex !== -1) {
                      const rect = textEditorCanvas.getBoundingClientRect();
                      const mouseX = (e.clientX - rect.left) * (textEditorCanvas.width / rect.width);
                      const mouseY = (e.clientY - rect.top) * (textEditorCanvas.height / rect.height);
                      
                      // Check if mouse is over the resize handle
                      if (isOverResizeHandle(mouseX, mouseY, textObjects[selectedTextObjectIndex])) {
                          textEditorCanvas.style.cursor = 'nwse-resize';
                      } else if (getTextObjectAtPosition(mouseX, mouseY) !== -1) {
                          textEditorCanvas.style.cursor = 'grab';
                      } else {
                          textEditorCanvas.style.cursor = 'default';
                      }
                } else {
                      textEditorCanvas.style.cursor = 'default';
                  }
              }
              
              // Handle end of drag operation
              if (isTextObjectDragging) {
                  console.log('Stopping drag operation');
                  isTextObjectDragging = false;
                  
                  // If a text object is selected and we have event data
                  if (selectedTextObjectIndex !== -1 && e && e.clientX !== undefined) {
                      // Check if mouse is still over the text
                      const rect = textEditorCanvas.getBoundingClientRect();
                      const mouseX = (e.clientX - rect.left) * (textEditorCanvas.width / rect.width);
                      const mouseY = (e.clientY - rect.top) * (textEditorCanvas.height / rect.height);
                      
                      // Check if mouse is over the resize handle
                      if (isOverResizeHandle(mouseX, mouseY, textObjects[selectedTextObjectIndex])) {
                          textEditorCanvas.style.cursor = 'nwse-resize';
                      } else {
                          const isOverText = getTextObjectAtPosition(mouseX, mouseY) !== -1;
                          textEditorCanvas.style.cursor = isOverText ? 'grab' : 'default';
                          console.log('Mouse is over text after drag:', isOverText);
                      }
                  } else {
                      textEditorCanvas.style.cursor = 'default';
                  }
              }
          };
          
          // Add cursor change when hovering over text objects
          textEditorCanvas.addEventListener('mousemove', (e) => {
              // Don't change cursor during drag operations
              if (isTextObjectDragging) return;
              
              const rect = textEditorCanvas.getBoundingClientRect();
              const scaleX = textEditorCanvas.width / rect.width;
              const scaleY = textEditorCanvas.height / rect.height;
              const mouseX = (e.clientX - rect.left) * scaleX;
              const mouseY = (e.clientY - rect.top) * scaleY;
              
              const hoveredObjectIndex = getTextObjectAtPosition(mouseX, mouseY);
              if (hoveredObjectIndex !== -1) {
                  textEditorCanvas.style.cursor = 'grab'; // Show grab cursor when hovering over text
                  console.log('Hovering over text object:', hoveredObjectIndex);
              } else {
                  textEditorCanvas.style.cursor = 'default';
              }
          });
          textEditorCanvas.addEventListener('mouseup', (e) => stopDragging(e));
          document.addEventListener('mouseup', (e) => stopDragging(e));

          textEditorCanvas.addEventListener('mouseout', (e) => {
              // Handle case when mouse leaves the canvas during drag or resize
              if (isTextObjectDragging || isResizing) {
                  console.log('Mouse left canvas during drag or resize operation');
                  // We'll rely on document.mouseup for stopping the operation
                  // But we should update the cursor now
                  textEditorCanvas.style.cursor = 'default';
                }
            });
        }

      // Apply text button removed - text is automatically applied

      // --- Helper function to trigger download ---
      function downloadDataUrl(dataUrl, filename) {
        const link = document.createElement('a');
        link.href = dataUrl;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // --- Event Listener for Download Final Image Button ---
      if (downloadFinalImageButton) {
        downloadFinalImageButton.addEventListener('click', () => {
            let dataURL;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            let filename = `thumbnail-${timestamp}.png`;

            if (textEditorCanvas && textEditorCanvas.getContext('2d')) {
                // Always render current text state to canvas before download
                // This ensures text is always included even if "Apply Text" wasn't clicked
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = textEditorCanvas.width;
                tempCanvas.height = textEditorCanvas.height;
                
                // Draw base image
                if (loadedBaseImageForCanvas && loadedBaseImageForCanvas.complete && loadedBaseImageForCanvas.naturalWidth > 0) {
                    tempCtx.drawImage(loadedBaseImageForCanvas, 0, 0, tempCanvas.width, tempCanvas.height);
                }
                
                // Draw all text objects regardless of "applied" state
                if (textObjects && textObjects.length > 0) {
                    textObjects.forEach(textObj => {
                        if (textObj.text && textObj.text.trim() !== '') {
                            tempCtx.font = `${textObj.size}px "${textObj.fontFamily}"`;
                            tempCtx.fillStyle = textObj.color;
                            tempCtx.textBaseline = 'top';
                            
                            // Add stroke for better visibility
                            tempCtx.strokeStyle = '#000000';
                            tempCtx.lineWidth = 2;
                            tempCtx.strokeText(textObj.text, textObj.x, textObj.y);
                            tempCtx.fillText(textObj.text, textObj.x, textObj.y);
                        }
                    });
                filename = `thumbnail-with-text-${timestamp}.png`;
                    console.log('Downloading canvas with all current text objects.');
                } else {
                    filename = `thumbnail-${timestamp}.png`;
                    console.log('Downloading canvas with base image only (no text objects).');
                }
                
                dataURL = tempCanvas.toDataURL('image/png');
            } else if (loadedBaseImageForCanvas && loadedBaseImageForCanvas.complete && loadedBaseImageForCanvas.naturalWidth > 0) {
                // Fallback if canvas is not available
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = loadedBaseImageForCanvas.naturalWidth;
                tempCanvas.height = loadedBaseImageForCanvas.naturalHeight;
                tempCtx.drawImage(loadedBaseImageForCanvas, 0, 0);
                dataURL = tempCanvas.toDataURL('image/png');
                filename = `thumbnail-${timestamp}.png`;
                console.log('Downloading base image only (canvas not available).');
            } else {
                showAlert('Image not ready for download. Please ensure a preview is loaded properly.', 'error');
                console.error('Download attempt failed: Base image not fully loaded or canvas unavailable.');
                return;
            }

            if (dataURL) {
                downloadDataUrl(dataURL, filename);
                showAlert('Image download started.', 'success');
            } else {
                showAlert('Could not prepare image for download.', 'error');
            }
        });
      }

      // --- Event Listener for Upscale Final Image Button ---
      if (upscaleFinalImageButton) {

        
        // Define a manual function to handle button loading state
        function setButtonLoading(button, isLoading, loadingText) {
            if (!button) return;
            
            if (isLoading) {
                const originalText = button.textContent;
                button.setAttribute('data-original-text', originalText);
                button.innerHTML = '<span class="loading-spinner-inline"></span> ' + loadingText;
                button.disabled = true;
                button.classList.add('button-loading');
            } else {
                const originalText = button.getAttribute('data-original-text') || 'Upscale with Clarity AI';
                button.innerHTML = originalText;
                button.disabled = false;
                button.classList.remove('button-loading');
            }
        }
        
        upscaleFinalImageButton.addEventListener('click', async function() {

            
            // We'll use a default prompt if needed, so no need to block here
            if (!currentSelectedPromptForHQ && !currentSelectedImageUrlForHQ) {
                showAlert('Error: No image selected for upscaling.', 'error');
                if(precisionHQStatus) precisionHQStatus.textContent = 'Error: No image selected for upscaling.';
                return;
            }
            
            // Save the original preview image URL before upscaling
            originalPreviewImageUrl = currentSelectedImageUrlForHQ;
            
            // Save the original text objects before upscaling
            originalTextObjects = JSON.parse(JSON.stringify(textObjects));


            if(precisionHQStatus) {
                precisionHQStatus.innerHTML = '<span class="loading-spinner"></span> Upscaling image with Clarity Upscaler (Cost: 2 Credits)...';
                precisionHQStatus.className = 'info';
            }

            // Set button to loading state
            setButtonLoading(upscaleFinalImageButton, true, 'Upscaling with Clarity AI...');
            
            // Prepare text overlays
            const textOverlays = textObjects.map(textObj => {
                let fontNameForBackend = textObj.fontFilename || 'arial.ttf'; 
                if (fontNameForBackend.includes('/')) { 
                    fontNameForBackend = fontNameForBackend.substring(fontNameForBackend.lastIndexOf('/') + 1);
                }
                return {
                    text: textObj.text,
                    font_name: fontNameForBackend,
                    font_filename: fontNameForBackend,
                    font_size: parseInt(textObj.size, 10),
                    x: Math.round(textObj.x),
                    y: Math.round(textObj.y),
                    color: textObj.color,
                    canvas_width: textEditorCanvas.width,
                    canvas_height: textEditorCanvas.height
                };
            }).filter(obj => obj.text && obj.text.trim() !== '');

            // First, clear any text selection to avoid capturing selection highlights
            const previouslySelectedIndex = selectedTextObjectIndex;
            
            // Temporarily deselect all text objects
            if (selectedTextObjectIndex !== -1) {
                textObjects[selectedTextObjectIndex].isSelected = false;
                selectedTextObjectIndex = -1;
                
                // Redraw the canvas without selection
                drawCanvas();
            }
            
            // Now capture the current canvas state with any text overlays but without selection highlights
            const currentCanvasDataUrl = textEditorCanvas.toDataURL('image/png');
            const currentCanvasWidth = textEditorCanvas.width;
            const currentCanvasHeight = textEditorCanvas.height;



            
            // Restore selection if there was one
            if (previouslySelectedIndex !== -1) {
                selectedTextObjectIndex = previouslySelectedIndex;
                textObjects[selectedTextObjectIndex].isSelected = true;
                
                // Redraw with selection
                drawCanvas();
            }
            
            // For development mode with placeholder images, we can handle upscaling locally
            // But for testing the real API, we'll bypass this
            const testRealUpscalingApi = true; // Always true to ensure we use the real API
            
            if (USE_PLACEHOLDER_PREVIEWS && !testRealUpscalingApi) {

                
                // Simulate upscaling locally
                const simulateUpscale = async () => {
                    try {
                        // Load the image onto the canvas at a larger size
                        const tempImage = new Image();
                        tempImage.crossOrigin = "anonymous";
                        
                        tempImage.onload = () => {
                            // Create a larger canvas for "upscaled" image
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d');
                            
                            // Set dimensions to 2x the original (simulating 2x upscale)
                            const upscaledWidth = tempImage.naturalWidth * 1.5;
                            const upscaledHeight = tempImage.naturalHeight * 1.5;
                            
                            tempCanvas.width = upscaledWidth;
                            tempCanvas.height = upscaledHeight;
                            
                            // Draw the image at the larger size
                            tempCtx.drawImage(tempImage, 0, 0, upscaledWidth, upscaledHeight);
                            
                            // Get the data URL of the "upscaled" image
                            const upscaledDataUrl = tempCanvas.toDataURL('image/png');
                            
                            // Update the main canvas with this upscaled image
                            loadedBaseImageForCanvas.onload = () => {
                                textEditorCanvas.width = loadedBaseImageForCanvas.naturalWidth;
                                textEditorCanvas.height = loadedBaseImageForCanvas.naturalHeight;
                                ctx.clearRect(0, 0, textEditorCanvas.width, textEditorCanvas.height);
                                ctx.drawImage(loadedBaseImageForCanvas, 0, 0, textEditorCanvas.width, textEditorCanvas.height);
                                
                                // Redraw text objects
                                textObjects.forEach(textObj => {
                                    if (textObj && textObj.text) {
                                        ctx.font = `${textObj.size}px "${textObj.fontFamily}"`;
                                        ctx.fillStyle = textObj.color;
                                        ctx.strokeStyle = '#000000';
                                        ctx.lineWidth = 3;
                                        ctx.textAlign = 'left';
                                        ctx.textBaseline = 'top';
                                        
                                        ctx.strokeText(textObj.text, textObj.x, textObj.y);
                                        ctx.fillText(textObj.text, textObj.x, textObj.y);
                                    }
                                });
                                
                                // Update UI
                                if(precisionHQStatus) {
                                    precisionHQStatus.textContent = 'Image upscaled successfully (development mode)';
                                    precisionHQStatus.className = 'success';
                                }
                                showAlert('Image upscaled successfully (development mode)', 'success');
                                setButtonLoading(upscaleFinalImageButton, false);
                            };
                            loadedBaseImageForCanvas.src = upscaledDataUrl;
                        };
                        
                        tempImage.onerror = () => {
                            console.error('Failed to load image for local upscaling');
                            if(precisionHQStatus) {
                                precisionHQStatus.textContent = 'Failed to upscale image locally';
                                precisionHQStatus.className = 'error';
                            }
                            showAlert('Failed to upscale image', 'error');
                            setButtonLoading(upscaleFinalImageButton, false);
                        };
                        
                        tempImage.src = currentCanvasDataUrl; // Use the current canvas with text already applied
                    } catch (error) {
                        console.error('Error in local upscaling:', error);
                        if(precisionHQStatus) {
                            precisionHQStatus.textContent = `Error: ${error.message || 'Unknown error'}`;
                            precisionHQStatus.className = 'error';
                        }
                        showAlert(`Error: ${error.message || 'Unknown error'}`, 'error');
                        setButtonLoading(upscaleFinalImageButton, false);
                    }
                };
                
                // Execute the local upscaling
                simulateUpscale();
                return; // Skip the API call
            }
            
            // Prepare payload for API call (non-development mode or data URLs)


            
            // Check if the image URL is a data URL
            const isDataUrl = currentSelectedImageUrlForHQ && currentSelectedImageUrlForHQ.startsWith('data:');

            
            // For production, use a real prompt
            const defaultPrompt = "high quality, detailed image";

            const payload = {
                prompt: currentSelectedPromptForHQ || defaultPrompt, // Backend expects 'prompt', not 'base_prompt'
                original_image_url: currentCanvasDataUrl, // Send the current canvas state with text overlays
                is_data_url: true, // Always true since we're sending a data URL
                use_clarity_upscaler: true // Explicitly tell the backend to use clarity-upscaler
            };
            
            console.log('Payload:', payload);

            // We don't need to send text overlays separately since they're already on the canvas
            // The backend will just upscale the image as-is
            payload.skip_text_rendering = true; // Tell backend not to re-render text

            // Check authentication
            // First try to get token from localStorage
            let token = localStorage.getItem('jwtToken');
            
            // If not found, try to get from session variable
            if (!token && currentSession && currentSession.access_token) {
                token = currentSession.access_token;
                console.log('Using token from currentSession instead of localStorage');
            }
            
            console.log('Authentication token found:', token ? 'Yes' : 'No');
            
            if (!token) {
                showAlert('Authentication error. Please log in again.', 'error');
                if(precisionHQStatus) {
                    precisionHQStatus.textContent = 'Authentication failed.';
                    precisionHQStatus.className = 'error';
                }
                setButtonLoading(upscaleFinalImageButton, false);
                return;
            }

            try {
                // Make API request
                console.log('Making API request to generate-hq-thumbnail');
                const apiUrl = `${BACKEND_URL}/api/precision/generate-hq-thumbnail`;
                console.log('API URL:', apiUrl);
                
                // Log the exact payload being sent
                console.log('Final payload being sent:', JSON.stringify({
                    ...payload,
                    original_image_url: payload.original_image_url ? payload.original_image_url.substring(0, 50) + '...' : null
                }, null, 2));
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify(payload)
                });

                console.log('Response status:', response.status);
                console.log('Response headers:', [...response.headers.entries()]);
                
                // Get response text first for debugging
                const responseText = await response.text();
                console.log('Raw response:', responseText.length > 1000 ? 
                    responseText.substring(0, 500) + '... [truncated] ...' + responseText.substring(responseText.length - 500) : 
                    responseText);
                
                // Try to parse as JSON
                let data;
                try {
                    data = JSON.parse(responseText);
                    console.log('Parsed response data:', data);
                } catch (parseError) {
                    console.error('Failed to parse response as JSON:', parseError);
                    showAlert('Error: Invalid response from server', 'error');
                    setButtonLoading(upscaleFinalImageButton, false);
                    return;
                }
                
                setButtonLoading(upscaleFinalImageButton, false);

                if (response.ok) {
                    if(precisionHQStatus) {
                        precisionHQStatus.textContent = 'Image successfully upscaled with Clarity Upscaler! Displaying now.';
                        precisionHQStatus.className = 'success';
                    }
                    
                    if (data.image_url) {
                        console.log('Received upscaled image URL from backend');
                        
                        // Create a "TADA!" presentation for the upscaled image
                        const presentUpscaledImage = () => {
                            // Hide the text editing UI and action buttons
                            const textControlsContainer = document.getElementById('text-controls-container');
                            const textInputDetailsContainer = document.getElementById('text-input-details-container');
                            const finalImageActionsContainer = document.getElementById('final-image-actions-container');
                            
                            if (textControlsContainer) textControlsContainer.style.display = 'none';
                            if (textInputDetailsContainer) textInputDetailsContainer.style.display = 'none';
                            if (finalImageActionsContainer) finalImageActionsContainer.style.display = 'none';
                            
                            // Hide the canvas temporarily
                            if (textEditorCanvas) textEditorCanvas.style.display = 'none';
                            
                            // Create or get the upscaled image container
                            let upscaledContainer = document.getElementById('upscaled-image-container');
                            if (!upscaledContainer) {
                                upscaledContainer = document.createElement('div');
                                upscaledContainer.id = 'upscaled-image-container';
                                upscaledContainer.style.position = 'relative';
                                upscaledContainer.style.margin = '20px auto';
                                upscaledContainer.style.textAlign = 'center';
                                upscaledContainer.style.maxWidth = '90%';
                                upscaledContainer.style.boxShadow = '0 4px 20px rgba(0,0,0,0.3)';
                                upscaledContainer.style.borderRadius = '8px';
                                upscaledContainer.style.overflow = 'hidden';
                                upscaledContainer.style.backgroundColor = '#fff';
                                upscaledContainer.style.padding = '20px';
                                
                                // Add a header
                                const header = document.createElement('h3');
                                header.textContent = 'Your Upscaled Thumbnail';
                                header.style.margin = '0 0 15px 0';
                                header.style.color = '#333';
                                upscaledContainer.appendChild(header);
                                
                                // Create image element
                                const upscaledImg = document.createElement('img');
                                upscaledImg.id = 'upscaled-result-image';
                                upscaledImg.style.maxWidth = '100%';
                                upscaledImg.style.height = 'auto';
                                upscaledImg.style.borderRadius = '4px';
                                upscaledContainer.appendChild(upscaledImg);
                                
                                // Create action buttons container
                                const actionButtons = document.createElement('div');
                                actionButtons.style.marginTop = '15px';
                                actionButtons.style.display = 'flex';
                                actionButtons.style.justifyContent = 'center';
                                actionButtons.style.gap = '10px';
                                actionButtons.style.flexWrap = 'wrap';
                                
                                // Add file size info
                                const fileSizeInfo = document.createElement('div');
                                fileSizeInfo.id = 'upscaled-file-size-info';
                                fileSizeInfo.style.width = '100%';
                                fileSizeInfo.style.textAlign = 'center';
                                fileSizeInfo.style.marginBottom = '10px';
                                fileSizeInfo.style.fontSize = '0.9rem';
                                fileSizeInfo.style.color = '#666';
                                fileSizeInfo.textContent = 'Processing image...';
                                actionButtons.appendChild(fileSizeInfo);
                                
                                // Download Original Size button
                                const downloadOriginalBtn = document.createElement('button');
                                downloadOriginalBtn.textContent = 'Download Original Size';
                                downloadOriginalBtn.className = 'action-button';
                                downloadOriginalBtn.style.padding = '10px 20px';
                                downloadOriginalBtn.style.backgroundColor = '#4CAF50';
                                downloadOriginalBtn.style.color = 'white';
                                downloadOriginalBtn.style.border = 'none';
                                downloadOriginalBtn.style.borderRadius = '4px';
                                downloadOriginalBtn.style.cursor = 'pointer';
                                downloadOriginalBtn.onclick = () => {
                                    const link = document.createElement('a');
                                    link.href = upscaledImg.src;
                                    link.download = 'upscaled-thumbnail-original.png';
                                    document.body.appendChild(link);
                                    link.click();
                                    document.body.removeChild(link);
                                };
                                actionButtons.appendChild(downloadOriginalBtn);
                                
                                // Download YouTube-Ready PNG button
                                const downloadYouTubeBtn = document.createElement('button');
                                downloadYouTubeBtn.textContent = 'Download for YouTube (PNG)';
                                downloadYouTubeBtn.className = 'action-button';
                                downloadYouTubeBtn.style.padding = '10px 20px';
                                downloadYouTubeBtn.style.backgroundColor = '#FF0000'; // YouTube red
                                downloadYouTubeBtn.style.color = 'white';
                                downloadYouTubeBtn.style.border = 'none';
                                downloadYouTubeBtn.style.borderRadius = '4px';
                                downloadYouTubeBtn.style.cursor = 'pointer';
                                downloadYouTubeBtn.onclick = () => {
                                    // Create a temporary canvas to resize the image
                                    const tempCanvas = document.createElement('canvas');
                                    const tempCtx = tempCanvas.getContext('2d');
                                    tempCanvas.width = 1280;
                                    tempCanvas.height = 720;
                                    
                                    const img = new Image();
                                    img.onload = function() {
                                        // Draw the image resized to 1280x720
                                        tempCtx.drawImage(img, 0, 0, 1280, 720);
                                        
                                        // Convert to PNG with max quality
                                        const youtubeReadyDataUrl = tempCanvas.toDataURL('image/png', 1.0);
                                        
                                        // Create download link
                                        const link = document.createElement('a');
                                        link.href = youtubeReadyDataUrl;
                                        link.download = 'youtube-thumbnail-1280x720.png';
                                        document.body.appendChild(link);
                                        link.click();
                                        document.body.removeChild(link);
                                    };
                                    img.src = upscaledImg.src;
                                };
                                actionButtons.appendChild(downloadYouTubeBtn);
                                
                                // Download YouTube-Ready JPEG button (smaller file size)
                                const downloadYouTubeJpegBtn = document.createElement('button');
                                downloadYouTubeJpegBtn.textContent = 'Download for YouTube (JPEG)';
                                downloadYouTubeJpegBtn.className = 'action-button';
                                downloadYouTubeJpegBtn.style.padding = '10px 20px';
                                downloadYouTubeJpegBtn.style.backgroundColor = '#FF0000'; // YouTube red
                                downloadYouTubeJpegBtn.style.color = 'white';
                                downloadYouTubeJpegBtn.style.border = 'none';
                                downloadYouTubeJpegBtn.style.borderRadius = '4px';
                                downloadYouTubeJpegBtn.style.cursor = 'pointer';
                                downloadYouTubeJpegBtn.style.opacity = '0.9';
                                downloadYouTubeJpegBtn.onclick = () => {
                                    // Create a temporary canvas to resize the image
                                    const tempCanvas = document.createElement('canvas');
                                    const tempCtx = tempCanvas.getContext('2d');
                                    tempCanvas.width = 1280;
                                    tempCanvas.height = 720;
                                    
                                    const img = new Image();
                                    img.onload = function() {
                                        // Draw the image resized to 1280x720
                                        tempCtx.drawImage(img, 0, 0, 1280, 720);
                                        
                                        // Convert to JPEG with high quality (0.9)
                                        // JPEG is more compressed than PNG and typically stays under 2MB
                                        const youtubeReadyDataUrl = tempCanvas.toDataURL('image/jpeg', 0.9);
                                        
                                        // Create download link
                                        const link = document.createElement('a');
                                        link.href = youtubeReadyDataUrl;
                                        link.download = 'youtube-thumbnail-1280x720.jpg';
                                        document.body.appendChild(link);
                                        link.click();
                                        document.body.removeChild(link);
                                        
                                        // Check and display the estimated file size
                                        estimateFileSize(youtubeReadyDataUrl, 'YouTube-Ready JPEG (1280x720)');
                                    };
                                    img.src = upscaledImg.src;
                                };
                                actionButtons.appendChild(downloadYouTubeJpegBtn);
                                
                                // Back button
                                const backBtn = document.createElement('button');
                                backBtn.textContent = 'Back to Editor';
                                backBtn.className = 'action-button';
                                backBtn.style.padding = '10px 20px';
                                backBtn.style.backgroundColor = '#2196F3';
                                backBtn.style.color = 'white';
                                backBtn.style.border = 'none';
                                backBtn.style.borderRadius = '4px';
                                backBtn.style.cursor = 'pointer';
                                backBtn.onclick = () => {
                                    // Hide upscaled container and show canvas again
                                    upscaledContainer.style.display = 'none';
                                    if (textEditorCanvas) {
                                        textEditorCanvas.style.display = 'block';
                                        
                                        // Scroll to the canvas editor
                                        textEditorCanvas.scrollIntoView({
                                            behavior: 'smooth',
                                            block: 'start'
                                        });
                                    }
                                    
                                    // Show text controls and action buttons again
                                    const textControlsContainer = document.getElementById('text-controls-container');
                                    const textInputDetailsContainer = document.getElementById('text-input-details-container');
                                    const finalImageActionsContainer = document.getElementById('final-image-actions-container');
                                    
                                    if (textControlsContainer) textControlsContainer.style.display = 'block';
                                    if (textInputDetailsContainer) textInputDetailsContainer.style.display = 'flex';
                                    if (finalImageActionsContainer) finalImageActionsContainer.style.display = 'flex';
                                    
                                    // Restore the original preview image instead of keeping the upscaled one
                                    if (originalPreviewImageUrl) {
                                        console.log('Restoring original preview image:', originalPreviewImageUrl);
                                        
                                        // Update current selected image URL
                                        currentSelectedImageUrlForHQ = originalPreviewImageUrl;
                                        
                                        // Reload the original image into the canvas
                                        loadedBaseImageForCanvas = new Image();
                                        loadedBaseImageForCanvas.crossOrigin = "anonymous";
                        loadedBaseImageForCanvas.onload = () => {
                            if (textEditorCanvas && loadedBaseImageForCanvas) {
                                textEditorCanvas.width = loadedBaseImageForCanvas.naturalWidth;
                                textEditorCanvas.height = loadedBaseImageForCanvas.naturalHeight;
                                                
                                                // Restore the original text objects
                                                textObjects = JSON.parse(JSON.stringify(originalTextObjects));
                                                
                                                // Redraw the canvas with the original image and text
                                                drawCanvas();
                                                
                                                if (precisionHQStatus) {
                                                    precisionHQStatus.textContent = 'Returned to original preview image.';
                                                    precisionHQStatus.className = 'info';
                                                }
                                            }
                                        };
                                        loadedBaseImageForCanvas.onerror = () => {
                                            console.error('Error loading original preview image:', originalPreviewImageUrl);
                                            if (precisionHQStatus) {
                                                precisionHQStatus.textContent = 'Error: Could not restore original preview image.';
                                                precisionHQStatus.className = 'error';
                                            }
                                        };
                                        loadedBaseImageForCanvas.src = originalPreviewImageUrl;
                                    }
                                };
                                actionButtons.appendChild(backBtn);
                                
                                upscaledContainer.appendChild(actionButtons);
                                
                                // Add to DOM
                                const canvasParent = textEditorCanvas.parentNode;
                                canvasParent.insertBefore(upscaledContainer, textEditorCanvas);
                                
                                // Scroll to the upscaled image container immediately
                                upscaledContainer.scrollIntoView({
                                    behavior: 'smooth',
                                    block: 'start'
                                });
                            } else {
                                // If container exists, just make it visible
                                upscaledContainer.style.display = 'block';
                                
                                // Scroll to the upscaled image container immediately
                                upscaledContainer.scrollIntoView({
                                    behavior: 'smooth',
                                    block: 'start'
                                });
                                
                                // Get the image element
                                const upscaledImg = document.getElementById('upscaled-result-image');
                                if (upscaledImg) {
                                    // Update image src below
                                }
                            }
                            
                            // Set the image source
                            const upscaledImg = document.getElementById('upscaled-result-image');
                            if (upscaledImg) {
                                upscaledImg.src = data.image_url;
                                upscaledImg.alt = 'Upscaled Thumbnail';
                                
                                // Check and display the original file size when image loads
                                upscaledImg.onload = function() {
                                    estimateFileSize(data.image_url, 'Original');
                                    
                                    // Create YouTube-ready versions for file size comparison
                                    const tempCanvas = document.createElement('canvas');
                                    const tempCtx = tempCanvas.getContext('2d');
                                    tempCanvas.width = 1280;
                                    tempCanvas.height = 720;
                                    tempCtx.drawImage(upscaledImg, 0, 0, 1280, 720);
                                    
                                    // Compare PNG and JPEG sizes
                                    const pngDataUrl = tempCanvas.toDataURL('image/png', 1.0);
                                    estimateFileSize(pngDataUrl, 'YouTube-Ready PNG (1280x720)');
                                    
                                    const jpegDataUrl = tempCanvas.toDataURL('image/jpeg', 0.9);
                                    estimateFileSize(jpegDataUrl, 'YouTube-Ready JPEG (1280x720)');
                                    
                                    // Scroll to the upscaled image container
                                    const upscaledContainer = document.getElementById('upscaled-image-container');
                                    if (upscaledContainer) {
                                        // Use smooth scrolling behavior
                                        upscaledContainer.scrollIntoView({
                                            behavior: 'smooth',
                                            block: 'start'
                                        });
                                    }
                                }
                            }
                            
                            // Function to estimate file size from data URL
                            function estimateFileSize(dataUrl, label) {
                                // For data URLs, we can estimate size by removing the header and calculating base64 length
                                if (dataUrl.startsWith('data:')) {
                                    const base64String = dataUrl.split(',')[1];
                                    // Base64 encodes 3 bytes into 4 characters, so we can approximate
                                    const approximateBytes = (base64String.length * 3) / 4;
                                    const fileSizeInfo = document.getElementById('upscaled-file-size-info');
                                    
                                    if (fileSizeInfo) {
                                        // Convert to MB with 2 decimal places
                                        const mbSize = (approximateBytes / (1024 * 1024)).toFixed(2);
                                        
                                        // Update file size information
                                        if (label === 'Original') {
                                            fileSizeInfo.innerHTML = `<strong>Original Size:</strong> ~${mbSize} MB`;
                                            
                                            // Add warning if file is too large for YouTube
                                            if (approximateBytes > 2 * 1024 * 1024) {
                                                fileSizeInfo.innerHTML += ` <span style="color: #f44336;">(Too large for YouTube's 2MB limit)</span>`;
                                            }
                                        } else {
                                            // For YouTube version, append to existing info
                                            fileSizeInfo.innerHTML += `<br><strong>${label}:</strong> ~${mbSize} MB`;
                                            
                                            if (approximateBytes > 2 * 1024 * 1024) {
                                                fileSizeInfo.innerHTML += ` <span style="color: #f44336;">(Still over YouTube's 2MB limit)</span>`;
                                            } else {
                                                fileSizeInfo.innerHTML += ` <span style="color: #4CAF50;">(Good for YouTube)</span>`;
                                            }
                                        }
                                    }
                                    
                                    return approximateBytes;
                                }
                                return 0;
                            }
                        };
                        
                        // Also update the canvas in the background
                        loadedBaseImageForCanvas.onload = () => {
                            if (textEditorCanvas && loadedBaseImageForCanvas) {
                                textEditorCanvas.width = loadedBaseImageForCanvas.naturalWidth;
                                textEditorCanvas.height = loadedBaseImageForCanvas.naturalHeight;
                                ctx.clearRect(0, 0, textEditorCanvas.width, textEditorCanvas.height);
                                ctx.drawImage(loadedBaseImageForCanvas, 0, 0, textEditorCanvas.width, textEditorCanvas.height);
                                
                                // Update text object positions and sizes
                                if (payload.skip_text_rendering && textObjects.length > 0) {
                                    const scaleX = textEditorCanvas.width / currentCanvasWidth;
                                    const scaleY = textEditorCanvas.height / currentCanvasHeight;
                                    
                                    textObjects.forEach(textObj => {
                                        textObj.x = textObj.x * scaleX;
                                        textObj.y = textObj.y * scaleY;
                                        textObj.size = Math.round(textObj.size * ((scaleX + scaleY) / 2));
                                    });
                                    
                                    console.log('Text object positions and sizes updated for upscaled canvas');
                                }
                                
                                // Store the original preview image URL before upscaling
                                originalPreviewImageUrl = currentSelectedImageUrlForHQ;
                                
                                // Present the upscaled image in a more prominent way
                                presentUpscaledImage();
                            }
                        };
                        loadedBaseImageForCanvas.src = data.image_url;
                    } else {
                         console.error('HQ image URL missing in response.');
                         if(precisionHQStatus) {
                            precisionHQStatus.textContent = 'Error: HQ Image data not received.';
                            precisionHQStatus.className = 'error';
                        }
                    }

                    // Update state
                    isTextAppliedToPreview = true;

                    if (data.credits_remaining !== undefined) {
                        // Update credits display if available
                        console.log('Credits remaining:', data.credits_remaining);
                        // We'll skip calling updateCreditsDisplay since it's not defined
                        // Just update any credits display elements directly if needed
                        const creditsDisplayElement = document.getElementById('credits-display');
                        if (creditsDisplayElement) {
                            creditsDisplayElement.textContent = `Credits: ${data.credits_remaining}`;
                        }
                    }
                    showAlert('Upscaled image generated and displayed.', 'success');
                } else {
                    // Handle error response
                    let errorMessage = data.error || 'Error generating HQ image.';
                    if (response.status === 402) {
                        errorMessage = data.error || 'Insufficient credits for upscaling.';
                    }
                    if(precisionHQStatus) {
                        precisionHQStatus.textContent = `Error: ${errorMessage}`;
                        precisionHQStatus.className = 'error';
                    }
                    showAlert(errorMessage, 'error');
                }
            } catch (error) {
                // Handle network errors
                console.error('Error upscaling image:', error);
                
                // Show detailed error message
                const errorMessage = error.message || 'Unknown error';
                if(precisionHQStatus) {
                    precisionHQStatus.textContent = `Error: ${errorMessage}`;
                    precisionHQStatus.className = 'error';
                }
                
                // Check if it's a CORS error
                if (errorMessage.includes('CORS') || errorMessage.includes('cross-origin')) {
                    showAlert('CORS error: The browser blocked the request. Check backend CORS settings.', 'error');
                } else {
                    showAlert(`Error: ${errorMessage}`, 'error');
            }
                
                setButtonLoading(upscaleFinalImageButton, false);
            }
        });
      }

      // --- Canvas Mouse Events for Text Dragging ---
      // Note: The main text object dragging functionality is now handled in the multi-text object approach
      // with the mousedown, mousemove, and mouseup event listeners defined earlier
      // --- End of Canvas Mouse Events ---

          if (backToPreviewsButton) {
        backToPreviewsButton.addEventListener('click', () => {
            if (precisionUseFlowContainer) precisionUseFlowContainer.style.display = 'none';
            // Keep the video topic input hidden and show the previews
            if (precisionStep1VideoTopic) precisionStep1VideoTopic.style.display = 'none';
            if (precisionPreviewsContainer) precisionPreviewsContainer.style.display = 'block';
            
            // Reset text application state
            isTextAppliedToPreview = false;
            appliedTextParameters = null;
            isTextEditingLocked = false;

            // Clear caption and re-enable inputs
            if (captionTextInput) captionTextInput.value = '';
            if (captionTextInput) captionTextInput.disabled = false;
            if (fontButtonContainer) fontButtonContainer.disabled = false;
            if (fontSizeInput) fontSizeInput.disabled = false;

            // Reset button visibility
            // Apply text button removed
            if (finalImageActionsContainer) finalImageActionsContainer.style.display = 'flex'; // Show Download/Upscale

            // Optionally, clear any status messages from the HQ flow
            if (precisionHQStatus) precisionHQStatus.textContent = '';

            // Hide the upscaled image container if it exists
            const upscaledContainer = document.getElementById('upscaled-image-container');
            if (upscaledContainer) {
                upscaledContainer.style.display = 'none';
            }
            
            // Hide the canvas editor area to reset the flow properly
            const canvasEditorArea = document.getElementById('canvas-editor-area');
            if (canvasEditorArea) {
                canvasEditorArea.style.display = 'none';
            }
            
            // Make sure text controls are ready for next use
            const textControlsContainer = document.getElementById('text-controls-container');
            const textInputDetailsContainer = document.getElementById('text-input-details-container');
            
            if (textControlsContainer) {
                // Don't show it now, but make sure it's not explicitly hidden
                // so it will appear when a new image is selected
                textControlsContainer.style.removeProperty('display');
            }
            
            if (textInputDetailsContainer) {
                // Don't show it now, but make sure it's not explicitly hidden
                textInputDetailsContainer.style.removeProperty('display');
            }

            // Reset text objects array
            textObjects = [];
            selectedTextObjectIndex = -1;
            
            // Reset the original preview image URL to prevent issues with future selections
            originalPreviewImageUrl = '';
            
            // Reset the current selected image URL to prevent previous upscaled image from affecting new selections
            currentSelectedImageUrlForHQ = '';

            // Redraw canvas to remove any text overlay from previous state
            drawCanvas();
        });
     }
    
    // Edit Modal Handlers
    const editModal = document.getElementById('edit-modal');
    const closeEditModalButton = document.getElementById('close-edit-modal');
    const cancelEditButton = document.getElementById('cancel-edit-button');
    const applyEditButton = document.getElementById('apply-edit-button');
    const editInstructions = document.getElementById('edit-instructions');
    
    if (closeEditModalButton) {
        closeEditModalButton.addEventListener('click', () => {
            if (editModal) editModal.style.display = 'none';
        });
    }
    
    // Close modal when clicking outside of it
    if (editModal) {
        editModal.addEventListener('click', (event) => {
            if (event.target === editModal) {
                editModal.style.display = 'none';
            }
        });
    }
    
    if (cancelEditButton) {
        cancelEditButton.addEventListener('click', () => {
            if (editModal) editModal.style.display = 'none';
        });
    }
    
    if (applyEditButton && editInstructions && editModal) {
        applyEditButton.addEventListener('click', async () => {
            console.log('🔍 Edit Apply button clicked');
            
            const instructions = editInstructions.value.trim();
            if (!instructions) {
                // Show error message if no instructions provided
                alert('Please describe what changes you would like to make to the image.');
                return;
            }
            
            // Get the original prompt from the modal's dataset
            const originalPrompt = editModal.dataset.originalPrompt;
            if (!originalPrompt) {
                alert('Error: Could not find the original prompt for this image.');
                return;
            }
            
            console.log(`🔍 Edit flow - Original prompt: ${originalPrompt}`);
            console.log(`🔍 Edit flow - Instructions: ${instructions}`);
            
            // Check if user has enough credits
            if (currentUserCredits === null || currentUserCredits < 1) {
                alert('Not enough credits. Please buy more credits to use this feature.');
                return;
            }
            
            // Disable the button and show loading state
            applyEditButton.disabled = true;
            const originalButtonText = applyEditButton.textContent;
            applyEditButton.innerHTML = '<span class="loading-spinner-inline"></span> Generating...';
            
            try {
                // Hide the modal
                editModal.style.display = 'none';
                
                // Clear existing previews
                if (precisionPreviewsGrid) {
                    precisionPreviewsGrid.innerHTML = '';
                }
                
                // Show loading message in the previews container
                if (precisionPreviewsStatus) {
                    precisionPreviewsStatus.innerHTML = '<span class="loading-spinner"></span> Refining prompt with AI...';
                    precisionPreviewsStatus.className = 'info';
                }
                
                console.log('🔍 Edit flow - Starting AI refinement process');
                
                try {
                    // Get the image URL for reference
                    const editPreviewImage = document.getElementById('edit-preview-image');
                    const imageUrl = editPreviewImage ? editPreviewImage.src : null;
                    
                    // Call the AI to refine the prompt
                    const response = await fetch(`${BACKEND_URL}/api/precision/refine-prompt`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${currentSession.access_token}`
                        },
                        body: JSON.stringify({
                            original_prompt: originalPrompt,
                            refinement_instructions: instructions,
                            image_url: imageUrl
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.error || `HTTP error! status: ${response.status}`);
                    }
                    
                    const refinedPrompt = data.refined_prompt;
                    
                    // DEV: Enhanced logging for prompt refinement
                    console.group('AI Prompt Refinement');
                    console.log('Original prompt:', data.original_prompt);
                    console.log('Refinement instructions:', data.refinement_instructions);
                    console.log('Refined prompt:', refinedPrompt);
                    console.log('Comparison:');
                    console.table({
                        'Original': data.original_prompt,
                        'Instructions': data.refinement_instructions,
                        'Refined': refinedPrompt
                    });
                    console.groupEnd();
                    
                    // Update status message
                    if (precisionPreviewsStatus) {
                        precisionPreviewsStatus.innerHTML = '<span class="loading-spinner"></span> Generating refined previews...';
                    }
                    
                    // Generate new previews using the AI-refined prompt
                    // Pass the refined prompt and mark it as a refinement
                    await generateAndDisplayPrecisionPreviews(refinedPrompt, precisionPreviewsStatus, applyEditButton, true, true);
                } catch (error) {
                    console.error('Error in edit flow:', error);
                    if (precisionPreviewsStatus) {
                        precisionPreviewsStatus.textContent = `Error: ${error.message}`;
                        precisionPreviewsStatus.className = 'error';
                    }
                    // No fallback - just show the error
                }
                
                // Reset the edit instructions field
                editInstructions.value = '';
                
            } catch (error) {
                console.error('Error generating refined previews:', error);
                if (precisionPreviewsStatus) {
                    precisionPreviewsStatus.textContent = `Error: ${error.message}`;
                    precisionPreviewsStatus.className = 'error';
                }
                // Show the modal again in case of error
                editModal.style.display = 'flex';
            } finally {
                // Re-enable the button and restore original text
                applyEditButton.disabled = false;
                applyEditButton.innerHTML = originalButtonText;
            }
        });
    }
      // --- Helper function to update UI controls based on selected text object ---
      function updateControlsForSelectedText() {
          if (selectedTextObjectIndex === -1 || !textObjects[selectedTextObjectIndex]) {
              if (captionTextInput) captionTextInput.value = '';
              if (fontSizeInput) fontSizeInput.value = '50';
              if (textColorPicker) textColorPicker.value = '#FFFFFF';
              if (fontButtonContainer) {
                  const currentActive = fontButtonContainer.querySelector('.font-button.active');
                  if (currentActive) currentActive.classList.remove('active');
                  
                  // Try to find AlfaSlabOne button first as the default
                  const alfaSlabOneButton = Array.from(fontButtonContainer.querySelectorAll('.font-button'))
                      .find(btn => btn.dataset.fontFilenameBackend === "AlfaSlabOne-Regular.ttf");
                  
                  if (alfaSlabOneButton) {
                      alfaSlabOneButton.classList.add('active');
                      selectedFontFamilyForCSS = alfaSlabOneButton.dataset.fontFamilyCss;
                      selectedFontFilenameForBackend = alfaSlabOneButton.dataset.fontFilenameBackend;
                  } else {
                      // Fall back to first button if AlfaSlabOne not found
                  const firstFontButton = fontButtonContainer.querySelector('.font-button');
                  if (firstFontButton) {
                       firstFontButton.classList.add('active');
                       selectedFontFamilyForCSS = firstFontButton.dataset.fontFamilyCss;
                       selectedFontFilenameForBackend = firstFontButton.dataset.fontFilenameBackend;
                  } else {
                       selectedFontFamilyForCSS = 'Arial';
                       selectedFontFilenameForBackend = 'arial.ttf';
                      }
                  }
              }
              if (captionTextInput) captionTextInput.disabled = true;
              if (fontSizeInput) fontSizeInput.disabled = true;
              if (textColorPicker) textColorPicker.disabled = true;
              if (fontButtonContainer) {
                  fontButtonContainer.querySelectorAll('.font-button').forEach(btn => btn.disabled = true);
              }
                              // Apply text button removed
          } else {
              const selectedObject = textObjects[selectedTextObjectIndex];
              if (captionTextInput) captionTextInput.value = selectedObject.text;
              if (fontSizeInput) fontSizeInput.value = selectedObject.size;
              if (textColorPicker) textColorPicker.value = selectedObject.color;
              if (fontButtonContainer) {
                  const currentActive = fontButtonContainer.querySelector('.font-button.active');
                  if (currentActive) currentActive.classList.remove('active');
                  const fontButtons = fontButtonContainer.querySelectorAll('.font-button');
                  let foundButton = false;
                  fontButtons.forEach(button => {
                      if (button.dataset.fontFilenameBackend === selectedObject.fontFilename) {
                          button.classList.add('active');
                          selectedFontFamilyForCSS = selectedObject.fontFamily;
                          selectedFontFilenameForBackend = selectedObject.fontFilename;
                          foundButton = true;
                      }
                  });
                  if (!foundButton && fontButtons.length > 0) {
                       fontButtons[0].click();
                  } else if (fontButtons.length === 0) {
                      selectedFontFamilyForCSS = 'Arial';
                      selectedFontFilenameForBackend = 'arial.ttf';
                  }
              }
              if (captionTextInput) captionTextInput.disabled = false;
              if (fontSizeInput) fontSizeInput.disabled = false;
              if (textColorPicker) textColorPicker.disabled = false;
              if (fontButtonContainer) {
                   fontButtonContainer.querySelectorAll('.font-button').forEach(btn => btn.disabled = false);
              }
              // Apply text button has been removed
          }
      }



      // --- End of Precision Mode "Use" Flow ---

     // --- Tab switching function ---
     document.addEventListener('DOMContentLoaded', function () {
        generateFontUI(); // Initialize the font buttons and @font-face rules.

        const tabs = document.querySelectorAll('.tab-button');
        const tabContents = [
            document.getElementById('prompt-gen-tab-content'),
            document.getElementById('asset-extraction-content'),
            document.getElementById('style-profile-content')
        ];
        const howItWorksSection = document.getElementById('how-it-works-section');

        function switchTab(clickedTab) {
            // Remove active class from all tabs
            tabs.forEach(t => t.classList.remove('active'));
            
            // Add active class to clicked tab
            clickedTab.classList.add('active');
            
            // Hide all tab contents
            tabContents.forEach(content => {
                if (content) content.style.display = 'none';
            });
            
            // Show the corresponding content
            if (clickedTab.id === 'tab-prompt-gen' && tabContents[0]) {
                tabContents[0].style.display = 'block';
                if (howItWorksSection) howItWorksSection.style.display = 'block';
            } else if (clickedTab.id === 'tab-asset-extraction' && tabContents[1]) {
                tabContents[1].style.display = 'block';
                if (howItWorksSection) howItWorksSection.style.display = 'none';
                
                // Reset sub-tabs and make sure Quick Mode is hidden when switching to Object Extraction tab
                const quickModeContent = document.getElementById('quick-mode-content');
                const subTabQuickButton = document.getElementById('sub-tab-quick');
                const subTabPrecisionButton = document.getElementById('sub-tab-precision');
                const precisionModeContent = document.getElementById('precision-mode-content');
                
                if (quickModeContent) {
                    quickModeContent.classList.remove('active');
                }
                if (subTabQuickButton) {
                    subTabQuickButton.classList.remove('active');
                }
                if (subTabPrecisionButton) {
                    subTabPrecisionButton.classList.add('active');
                }
                if (precisionModeContent) {
                    precisionModeContent.classList.add('active');
                }
            } else if (clickedTab.id === 'tab-style-profile' && tabContents[2]) {
                tabContents[2].style.display = 'block';
                if (howItWorksSection) howItWorksSection.style.display = 'none';
                
                // Reset sub-tabs and make sure Quick Mode is hidden when switching to Style Profile tab
                const quickModeContent = document.getElementById('quick-mode-content');
                const subTabQuickButton = document.getElementById('sub-tab-quick');
                const subTabPrecisionButton = document.getElementById('sub-tab-precision');
                const precisionModeContent = document.getElementById('precision-mode-content');
                
                if (quickModeContent) {
                    quickModeContent.classList.remove('active');
                }
                if (subTabQuickButton) {
                    subTabQuickButton.classList.remove('active');
                }
                if (subTabPrecisionButton) {
                    subTabPrecisionButton.classList.add('active');
                }
                if (precisionModeContent) {
                    precisionModeContent.classList.add('active');
                }
            }
            
            updateContentView(); // Update main view based on auth status and new tab
        }

        tabs.forEach(tab => {
            tab.addEventListener('click', function(event) {
                switchTab(event.currentTarget);
            });
        });

        // Initialize view for the default active tab or the first tab
        const initiallyActiveTab = document.querySelector('.tab-button.active');
        if (initiallyActiveTab) {
            switchTab(initiallyActiveTab);
        } else if (tabs.length > 0) {
            // If no tab is marked active in HTML, activate the first one.
            // Ensure 'active' class is also set on the HTML element if not already.
            tabs[0].classList.add('active'); 
            switchTab(tabs[0]);
        }
        updateControlsForSelectedText(); // Initialize UI state for text controls
    });

     // --- Preview Loading Animation Function ---
     function startPreviewLoadingAnimation() {
         let currentPreview = 1;
         const totalPreviews = 6;
         const loadingBar = document.getElementById('preview-loading-bar');
         const loadingText = document.getElementById('preview-loading-text');
         
         if (!loadingBar || !loadingText) return;
         
         // Reset initial state
         loadingBar.style.width = `${(1/totalPreviews) * 100}%`;
         loadingText.textContent = `Generating preview 1/${totalPreviews}...`;
         
         // Function to advance the progress bar
         const advanceProgress = () => {
             currentPreview++;
             
             if (currentPreview <= totalPreviews) {
                 // Update progress bar and text
                 const percentage = (currentPreview/totalPreviews) * 100;
                 loadingBar.style.width = `${percentage}%`;
                 loadingText.textContent = `Generating preview ${currentPreview}/${totalPreviews}...`;
                 
                 // Schedule the next update with a random time between 1-3 seconds
                 const nextDelay = Math.floor(Math.random() * 2000) + 1000;
                 setTimeout(advanceProgress, nextDelay);
             } else {
                 // When all previews are "generated", update the text to indicate processing
                 loadingText.textContent = 'Processing results...';
                 loadingBar.style.width = '100%';
             }
         };
         
         // Start the animation after a short delay
         setTimeout(advanceProgress, 1500);
     }

     // --- Helper: Display Status Messages ---
     function showStatus(element, message, type = 'info', duration = 0) {
         if (!element) { console.warn("showStatus: Element not found"); return; }
         const isPurchaseStatus = element.id === 'purchase-status';
         element.innerHTML = message; // Use innerHTML to allow basic formatting like links
         element.className = type + (isPurchaseStatus ? ' header-purchase-status' : '');
         if (duration > 0) {
             setTimeout(() => {
                 if (element.innerHTML === message) { // Check if message is still the same
                     element.innerHTML = '';
                     element.className = (isPurchaseStatus ? 'header-purchase-status' : '');
                 }
             }, duration);
         }
     }

     // --- Purchase Button Event Listener (Attached to user info container) ---
     if (userInfoContainer) {
         userInfoContainer.addEventListener('click', async (event) => {
             const button = event.target.closest('.buy-credits-button.header-buy-button');
             if (button && stripe) {
                 event.preventDefault();
                 if (!currentSession) { showStatus(purchaseStatusP, "Please log in to purchase credits.", 'warning', 3000); return; }
                 const priceId = button.dataset.priceId;
                 if (!priceId || priceId === "YOUR_STRIPE_PRICE_ID_HERE") { console.error("Buy button missing or has placeholder data-price-id attribute."); showStatus(purchaseStatusP, "Error: Purchase option not configured.", 'error', 5000); return; }

                 const originalButtonText = button.innerText;
                 showStatus(purchaseStatusP, "Processing...", 'info');
                 button.disabled = true; button.innerText = "Redirecting...";

                 try {
                     const token = currentSession.access_token;
                     const res = await fetch(`${BACKEND_URL}/create-checkout-session`, {
                         method: "POST", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${token}` },
                         body: JSON.stringify({ priceId: priceId })
                     });
                     const responseBody = await res.text(); let data;
                     try { data = JSON.parse(responseBody); } catch(e) { throw new Error(`Server returned invalid response (Status: ${res.status})`); }
                     if (!res.ok) { throw new Error(data.error || `Failed to start purchase (Status: ${res.status})`); }
                     if (data.url) { window.location.href = data.url; }
                     else { throw new Error("Could not get checkout URL from server."); }
                 } catch (err) {
                     console.error("Purchase initiation failed:", err);
                     showStatus(purchaseStatusP, `Error: ${err.message}`, 'error', 5000);
                     button.disabled = false; button.innerText = originalButtonText;
                     if (err.message.includes("Authent")) { showStatus(authStatusP, "Authentication error. Please log in again.", 'error'); await logout(); }
                 }
             }
         });
     } else { console.warn("User info container not found in DOM for purchase listener."); }


     // --- Tab switching function ---
     document.addEventListener('DOMContentLoaded', function () {
        generateFontUI(); // Initialize the font buttons and @font-face rules.

        const tabs = document.querySelectorAll('.tab-button');
        const tabContents = [
            document.getElementById('prompt-gen-tab-content'),
            document.getElementById('asset-extraction-content'),
            document.getElementById('style-profile-content')
        ];
        const howItWorksSection = document.getElementById('how-it-works-section');

        function switchTab(clickedTab) {
            // Remove active class from all tabs
            tabs.forEach(t => t.classList.remove('active'));
            
            // Add active class to clicked tab
            clickedTab.classList.add('active');
            
            // Hide all tab contents
            tabContents.forEach(content => {
                if (content) content.style.display = 'none';
            });
            
            // Show the corresponding content
            if (clickedTab.id === 'tab-prompt-gen' && tabContents[0]) {
                tabContents[0].style.display = 'block';
                if (howItWorksSection) howItWorksSection.style.display = 'block';
            } else if (clickedTab.id === 'tab-asset-extraction' && tabContents[1]) {
                tabContents[1].style.display = 'block';
                if (howItWorksSection) howItWorksSection.style.display = 'none';
                
                // Reset sub-tabs and make sure Quick Mode is hidden when switching to Object Extraction tab
                const quickModeContent = document.getElementById('quick-mode-content');
                const subTabQuickButton = document.getElementById('sub-tab-quick');
                const subTabPrecisionButton = document.getElementById('sub-tab-precision');
                const precisionModeContent = document.getElementById('precision-mode-content');
                
                if (quickModeContent) {
                    quickModeContent.classList.remove('active');
                }
                if (subTabQuickButton) {
                    subTabQuickButton.classList.remove('active');
                }
                if (subTabPrecisionButton) {
                    subTabPrecisionButton.classList.add('active');
                }
                if (precisionModeContent) {
                    precisionModeContent.classList.add('active');
                }
            } else if (clickedTab.id === 'tab-style-profile' && tabContents[2]) {
                tabContents[2].style.display = 'block';
                if (howItWorksSection) howItWorksSection.style.display = 'none';
                
                // Reset sub-tabs and make sure Quick Mode is hidden when switching to Style Profile tab
                const quickModeContent = document.getElementById('quick-mode-content');
                const subTabQuickButton = document.getElementById('sub-tab-quick');
                const subTabPrecisionButton = document.getElementById('sub-tab-precision');
                const precisionModeContent = document.getElementById('precision-mode-content');
                
                if (quickModeContent) {
                    quickModeContent.classList.remove('active');
                }
                if (subTabQuickButton) {
                    subTabQuickButton.classList.remove('active');
                }
                if (subTabPrecisionButton) {
                    subTabPrecisionButton.classList.add('active');
                }
                if (precisionModeContent) {
                    precisionModeContent.classList.add('active');
                }
            }
            
            updateContentView(); // Update main view based on auth status and new tab
        }

        tabs.forEach(tab => {
            tab.addEventListener('click', function(event) {
                switchTab(event.currentTarget);
            });
        });

        // Initialize view for the default active tab or the first tab
        const initiallyActiveTab = document.querySelector('.tab-button.active');
        if (initiallyActiveTab) {
            switchTab(initiallyActiveTab);
        } else if (tabs.length > 0) {
            // If no tab is marked active in HTML, activate the first one.
            // Ensure 'active' class is also set on the HTML element if not already.
            tabs[0].classList.add('active'); 
            switchTab(tabs[0]);
        }
        updateControlsForSelectedText(); // Initialize UI state for text controls
    });

     // --- Utility to update Credit UI and Button States ---
     function updateCreditState(credits) {
         currentUserCredits = credits;
         const creditsWrapper = creditsContainer ? creditsContainer.parentElement : null;

         // Update Credits Display in Header
         if (credits === 'loading') {
             creditsDisplaySpan.innerText = '...';
             if (creditsContainer) creditsContainer.style.display = 'inline-flex';
             if (creditsWrapper && creditsWrapper !== userInfoContainer) creditsWrapper.style.display = 'flex';
         } else if (credits !== null && typeof credits === 'number' && credits >= 0) {
             creditsDisplaySpan.innerText = credits;
             if (creditsContainer) creditsContainer.style.display = 'inline-flex';
             if (creditsWrapper && creditsWrapper !== userInfoContainer) creditsWrapper.style.display = 'flex';
         } else {
             if (creditsContainer) creditsContainer.style.display = 'none';
              if (creditsWrapper && creditsWrapper !== userInfoContainer) creditsWrapper.style.display = 'none';
             creditsDisplaySpan.innerText = '--';
         }

         // Update Thumbnail Generation Button State
         const canGenerateThumbnails = (credits !== null && typeof credits === 'number' && credits >= TOTAL_GENERATION_COST);
          if (confirmPromptButton) {
              confirmPromptButton.disabled = !canGenerateThumbnails;
              confirmPromptButton.innerText = `Generate ${NUM_IMAGES_EXPECTED} Thumbnails (Cost: ${TOTAL_GENERATION_COST} Credits)`;
              // Handle edge cases for button text
              if (credits === null && !currentSession) { confirmPromptButton.innerText = `Generate ${NUM_IMAGES_EXPECTED} Thumbnails (Login Required)`; confirmPromptButton.disabled = true; }
              else if (credits === null && currentSession) { confirmPromptButton.innerText = `Generate ${NUM_IMAGES_EXPECTED} Thumbnails (Credit Error)`; confirmPromptButton.disabled = true; }
          } else { console.warn("Element 'confirm-prompt-button' not found during credit state update."); }

         // Update Thumbnail Credit Warning Message
         if (creditWarningP) {
             if (credits !== null && typeof credits === 'number' && credits < TOTAL_GENERATION_COST) {
                  const creditsTargetElement = creditsContainer.closest('.user-info-container > div') || creditsContainer;
                  creditWarningP.innerHTML = `You need ${TOTAL_GENERATION_COST} credits (have ${credits}). <a href="#" onclick="event.preventDefault(); scrollToElement(creditsTargetElement.id || 'credits-container');">Buy More Credits?</a>`;
                  creditWarningP.style.display = 'block';
              } else {
                  creditWarningP.style.display = 'none';
                  creditWarningP.innerHTML = '';
              }
         }

         // --- NEW: Update Asset Extraction Button State ---
         const canExtractAssets = (credits !== null && typeof credits === 'number' && credits >= CREDIT_COST_PER_ASSET_EXTRACTION);
         if (extractAssetButton) {
             // Enable button only if credits are sufficient AND an image is selected AND description is entered
             const isReadyToExtract = canExtractAssets && selectedAssetImageDataUri && assetDescriptionInput?.value.trim();
             extractAssetButton.disabled = !isReadyToExtract;
             extractAssetButton.innerText = `Extract Asset (Cost: ${CREDIT_COST_PER_ASSET_EXTRACTION} Credits)`;
              // Handle edge cases for button text
             if (credits === null && !currentSession) { extractAssetButton.innerText = `Extract Asset (Login Required)`; extractAssetButton.disabled = true; }
             else if (credits === null && currentSession) { extractAssetButton.innerText = `Extract Asset (Credit Error)`; extractAssetButton.disabled = true; }
             else if (credits !== null && typeof credits === 'number' && credits < CREDIT_COST_PER_ASSET_EXTRACTION) {
                  extractAssetButton.innerText = `Extract Asset (Need ${CREDIT_COST_PER_ASSET_EXTRACTION} Credits)`;
                  extractAssetButton.disabled = true;
             }
         } else { console.warn("Element 'extract-asset-button' not found during credit state update."); }

         // --- NEW: Update Asset Extraction Status Message (for low credits) ---
         if (assetStatusP && credits !== null && typeof credits === 'number' && credits < CREDIT_COST_PER_ASSET_EXTRACTION) {
             const creditsTargetElement = creditsContainer.closest('.user-info-container > div') || creditsContainer;
              showStatus(assetStatusP, `Insufficient credits. You need ${CREDIT_COST_PER_ASSET_EXTRACTION} (have ${credits}). <a href="#" onclick="event.preventDefault(); scrollToElement(creditsTargetElement.id || 'credits-container');">Buy More</a>`, 'warning');
         } else if (assetStatusP && assetStatusP.innerText.includes("Insufficient credits")) {
             // Clear the low credit warning if credits are now sufficient
             showStatus(assetStatusP, '');
         }
     }

     // --- Function to Fetch User Credits ---
     async function fetchUserCredits() {
         if (!currentSession) { updateCreditState(null); return; }
         console.log("Fetching user credits...");
         updateCreditState('loading'); // Show loading state

         try {
             const token = currentSession.access_token;
             const res = await fetch(`${BACKEND_URL}/get_profile`, {
                 method: "GET", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${token}` }
             });
             const responseBody = await res.text(); let data;
             try { data = JSON.parse(responseBody); } catch(e) { throw new Error(`Server returned invalid response (Status: ${res.status})`); }
             if (!res.ok) { if (res.status === 401) { console.warn("fetchUserCredits received 401, letting auth listener handle logout."); return; } throw new Error(data.error || `Failed to fetch credits (Status: ${res.status})`); }
             updateCreditState(data.credits);
         } catch (err) {
             console.error("Error fetching credits:", err);
             if(currentSession) { showStatus(authStatusP, `Error loading credits: ${err.message}`, 'error'); }
             updateCreditState(null); // Error state
         }
     }


     // --- Auth Functions (Login, Signup, Logout, Google Sign-In) ---
     async function login() {
         showStatus(authStatusP, 'Logging in...', 'info');
         const email = document.getElementById('auth-email').value;
         const password = document.getElementById('auth-password').value;
         
         if (!email || !password) {
             showStatus(authStatusP, 'Please enter both email and password', 'warning');
             return;
         }
         
         try {
             // Attempt to sign in with password
             const { data, error } = await supabaseClient.auth.signInWithPassword({ email, password });
             
             if (error) {
                 // Check if the error is related to email verification
                 if (error.message && (error.message.toLowerCase().includes('email not confirmed') || 
                                        error.message.toLowerCase().includes('email confirmation') ||
                                        error.message.toLowerCase().includes('not verified'))) {
                     showStatus(authStatusP, 'Please verify your email before logging in. Check your inbox (and spam folder) for a verification link.', 'warning', 10000);
                     
                     // Add a button to resend verification email
                     const resendButton = document.createElement('button');
                     resendButton.innerText = 'Resend Verification Email';
                     resendButton.style.marginTop = '0.5rem';
                     resendButton.style.width = '100%';
                     resendButton.title = 'Click to send a new verification email if you did not receive the first one';
                     resendButton.onclick = async () => {
                         try {
                             showStatus(authStatusP, 'Sending verification email...', 'info');
                             const { data: resendData, error: resendError } = await supabaseClient.auth.resend({
                                 type: 'signup',
                                 email: email,
                                 options: {
                                     emailRedirectTo: `${window.location.origin}/app/`
                                 }
                             });
                             
                             if (resendError) {
                                 console.error("Error resending verification email:", resendError);
                                 showStatus(authStatusP, `Could not resend verification email: ${resendError.message}`, 'error', 10000);
                             } else {
                                 showStatus(authStatusP, 'Verification email resent. Please check your inbox.', 'success', 10000);
                             }
                         } catch (resendErr) {
                             console.error("Exception resending verification email:", resendErr);
                             showStatus(authStatusP, 'Could not resend verification email. Please try signing up again.', 'error', 10000);
                         }
                     };
                     
                     // Add the resend button to the auth status area
                     if (authStatusP.nextElementSibling && authStatusP.nextElementSibling.classList.contains('resend-button')) {
                         authStatusP.nextElementSibling.remove();
                     }
                     authStatusP.parentNode.insertBefore(resendButton, authStatusP.nextSibling);
                     resendButton.classList.add('resend-button');
                     
                     return;
                 }
                 
                 // Handle wrong password or email not found separately for better UX
                 if (error.message && (error.message.toLowerCase().includes('invalid login') || 
                                       error.message.toLowerCase().includes('invalid email') ||
                                       error.message.toLowerCase().includes('invalid password'))) {
                     showStatus(authStatusP, 'Invalid email or password', 'error');
                     return;
                 }
                 
                 throw error;
             }
             
             // Check if user is verified by checking if session exists
             if (!data.session) {
                 showStatus(authStatusP, 'Please verify your email before logging in. Check your inbox (and spam folder) for a verification link.', 'warning', 10000);
                 
                 // Add a button to resend verification email
                 const resendButton = document.createElement('button');
                 resendButton.innerText = 'Resend Verification Email';
                 resendButton.style.marginTop = '0.5rem';
                 resendButton.style.width = '100%';
                 resendButton.onclick = async () => {
                     try {
                         showStatus(authStatusP, 'Sending verification email...', 'info');
                         const { data: resendData, error: resendError } = await supabaseClient.auth.resend({
                             type: 'signup',
                             email: email,
                             options: {
                                 emailRedirectTo: `${window.location.origin}/app/`
                             }
                         });
                         
                         if (resendError) {
                             console.error("Error resending verification email:", resendError);
                             showStatus(authStatusP, `Could not resend verification email: ${resendError.message}`, 'error', 10000);
                         } else {
                             showStatus(authStatusP, 'Verification email resent. Please check your inbox.', 'success', 10000);
                         }
                     } catch (resendErr) {
                         console.error("Exception resending verification email:", resendErr);
                         showStatus(authStatusP, 'Could not resend verification email. Please try signing up again.', 'error', 10000);
                     }
                 };
                 
                 // Add the resend button to the auth status area
                 if (authStatusP.nextElementSibling && authStatusP.nextElementSibling.classList.contains('resend-button')) {
                     authStatusP.nextElementSibling.remove();
                 }
                 authStatusP.parentNode.insertBefore(resendButton, authStatusP.nextSibling);
                 resendButton.classList.add('resend-button');
                 
                 return;
             }
             
             // If we get here, user is verified and logged in successfully
             showStatus(authStatusP, 'Login successful! Loading app...', 'success');
             
             // Remove any resend button if it exists
             if (authStatusP.nextElementSibling && authStatusP.nextElementSibling.classList.contains('resend-button')) {
                 authStatusP.nextElementSibling.remove();
             }
         } catch (error) {
             console.error("Login Error:", error);
             showStatus(authStatusP, `Login Failed: ${error.message || 'Unknown error'}`, 'error');
         }
      }
     async function signup() {
          showStatus(authStatusP, "Signing up...", 'info');
          const email = document.getElementById("auth-email").value;
          const password = document.getElementById("auth-password").value;
          
          if (!email || !password) {
              showStatus(authStatusP, 'Please enter both email and password', 'warning');
              return;
          }
          
          if (password.length < 6) {
              showStatus(authStatusP, 'Password must be at least 6 characters long', 'warning');
              return;
          }
          
          // Validate email format
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          if (!emailRegex.test(email)) {
              showStatus(authStatusP, 'Please enter a valid email address', 'warning');
              return;
          }
          
          try {
              // Configure signup to require email confirmation
              const { data, error } = await supabaseClient.auth.signUp({
                email,
                password,
                options: {
                  emailRedirectTo: `${window.location.origin}/app/`,
                  data: {
                    confirmed_at: null // Ensure email confirmation is required
                  }
                }
              });
              
              // Log the raw response for debugging
              console.log("Signup response:", { data, error });
              
              // Check for the specific case of an existing user where Supabase doesn't return an error
              // but returns a user with no identities (this is a known pattern)
              if (data && data.user && data.user.identities && data.user.identities.length === 0) {
                  console.log("Detected existing user: user has no identities");
                  showStatus(authStatusP, "This email is already registered. Try logging in instead.", 'warning');
                  return;
              }

              if (error) {
                  console.error("Signup Error Object:", error);
                  // Check for various forms of "already registered" messages
                  const errorMsg = error.message ? error.message.toLowerCase() : '';
                  
                  // Check for common "user already exists" error patterns
                  if (errorMsg.includes("already") && 
                     (errorMsg.includes("registered") || errorMsg.includes("exists") || errorMsg.includes("taken"))) {
                      showStatus(authStatusP, "This email is already registered. Try logging in instead.", 'warning');
                  }
                  // Check for error code that might indicate an existing user
                  else if (error.status === 400 && errorMsg.includes("unique constraint")) {
                      showStatus(authStatusP, "This email is already registered. Try logging in instead.", 'warning');
                  }
                  else {
                      showStatus(authStatusP, `Signup failed: ${error.message}`, 'error');
                  }
              } else if (data && data.user) {
                  console.log("Signup Data Object:", data);
                                    console.log("User object details:", {
                      id: data.user.id,
                      email: data.user.email,
                      email_confirmed_at: data.user.email_confirmed_at,
                      created_at: data.user.created_at,
                      updated_at: data.user.updated_at,
                      has_identities: data.user.identities && data.user.identities.length > 0,
                      app_metadata: data.user.app_metadata,
                      is_new: data.user.app_metadata?.provider === 'email' && !data.user.email_confirmed_at
                  });
                  
                  // One final check - if we have a user with a confirmed email, it's an existing user
              if (data.user.email_confirmed_at) {
                  console.log("Detected existing user: email already confirmed");
                  showStatus(authStatusP, "This email is already registered. Try logging in instead.", 'warning');
                  return;
              }
              
              // Check if email verification is needed
              if (!data.session) {
                      // No session means email verification is required
                      showStatus(authStatusP, "Signup successful! Please check your email (including spam folder) for a verification link. You must verify your email before logging in.", 'success', 15000);
                      
                      // Clear the password field for security
                      document.getElementById("auth-password").value = "";
                      
                      // Add a button to resend verification email
                      const resendButton = document.createElement('button');
                      resendButton.innerText = 'Resend Verification Email';
                      resendButton.style.marginTop = '0.5rem';
                      resendButton.style.width = '100%';
                      resendButton.title = 'Click to send a new verification email if you did not receive the first one';
                      resendButton.onclick = async () => {
                          try {
                              showStatus(authStatusP, 'Sending verification email...', 'info');
                              const { data: resendData, error: resendError } = await supabaseClient.auth.resend({
                                  type: 'signup',
                                  email: email,
                                  options: {
                                      emailRedirectTo: `${window.location.origin}/app/`
                                  }
                              });
                              
                              if (resendError) {
                                  console.error("Error resending verification email:", resendError);
                                  showStatus(authStatusP, `Could not resend verification email: ${resendError.message}`, 'error', 10000);
                              } else {
                                  showStatus(authStatusP, 'Verification email resent. Please check your inbox.', 'success', 10000);
                              }
                          } catch (resendErr) {
                              console.error("Exception resending verification email:", resendErr);
                              showStatus(authStatusP, 'Could not resend verification email. Please try signing up again.', 'error', 10000);
                          }
                      };
                      
                      // Add the resend button to the auth status area
                      if (authStatusP.nextElementSibling && authStatusP.nextElementSibling.classList.contains('resend-button')) {
                          authStatusP.nextElementSibling.remove();
                      }
                      authStatusP.parentNode.insertBefore(resendButton, authStatusP.nextSibling);
                      resendButton.classList.add('resend-button');
                      
                      // Log the user out to ensure they verify email first
                      if (currentSession) {
                          await supabaseClient.auth.signOut();
                      }
                  } else {
                      // This shouldn't happen if email verification is properly enforced
                      console.warn("User was signed up and logged in without email verification");
                      showStatus(authStatusP, "Account created, but email verification is still required. Please check your inbox.", 'warning', 10000);
                      
                      // Force logout to ensure verification
                      await supabaseClient.auth.signOut();
                  }
              } else {
                  console.warn("Signup returned no error and no user data:", data);
                  showStatus(authStatusP, "Signup status unclear. Please check your email for verification instructions.", 'warning', 10000);
              }
          } catch (e) {
              showStatus(authStatusP, `Signup error: ${e.message}`, 'error');
          }
      }
     async function logout() {
         console.log("--- Logout function called ---");
         showStatus(authStatusP, "Logging out...", 'info');
         selectedAssetImageDataUri = null; // Clear selected asset on logout
         try {
             const { error } = await supabaseClient.auth.signOut();
             if (error) {
                 console.error("--- Supabase signOut error:", error.message);
                  currentSession = null; updateContentView(); updateCreditState(null);
                  showStatus(authStatusP, "Logout may have failed, please refresh if needed.", 'warning');
             } else {
                 console.log("--- Supabase signOut successful (callback pending) ---");
                 // The onAuthStateChange listener should handle the UI update
             }
         } catch (e) {
             console.error("--- Error during logout function execution:", e);
              currentSession = null; updateContentView(); updateCreditState(null);
              showStatus(authStatusP, "Error during logout, please refresh.", 'error');
         }
     }
     
     async function signInWithGoogle() {
         showStatus(authStatusP, 'Connecting to Google...', 'info');
         try {
             const { data, error } = await supabaseClient.auth.signInWithOAuth({
                 provider: 'google',
                 options: {
                     redirectTo: `${window.location.origin}/app/`
                 }
             });
             
             if (error) {
                 console.error('Google Sign-In Error:', error);
                 showStatus(authStatusP, `Google Sign-In failed: ${error.message}`, 'error');
             } else {
                 console.log('Google Sign-In initiated', data);
                 // The OAuth flow will redirect the user to Google's consent page
                 // After successful authentication, user will be redirected back to the app
                 // The onAuthStateChange listener will handle the session update
             }
         } catch (e) {
             console.error('Exception during Google Sign-In:', e);
             showStatus(authStatusP, `Error during Google Sign-In: ${e.message}`, 'error');
         }
     }
     
     // Forgot Password Modal Functions
     function showForgotPasswordModal() {
         const modal = document.getElementById('forgot-password-modal');
         if (modal) {
             modal.style.display = 'flex';
             document.getElementById('forgot-password-email').value = document.getElementById('auth-email').value || '';
             document.getElementById('forgot-password-status').textContent = '';
             // Focus on the email input
             setTimeout(() => {
                 document.getElementById('forgot-password-email').focus();
             }, 100);
         }
     }
     
     function closeForgotPasswordModal() {
         const modal = document.getElementById('forgot-password-modal');
         if (modal) {
             modal.style.display = 'none';
             document.getElementById('forgot-password-status').textContent = '';
         }
     }
     
     // Close modal when clicking outside of it
     window.addEventListener('click', (event) => {
         const modal = document.getElementById('forgot-password-modal');
         if (event.target === modal) {
             closeForgotPasswordModal();
         }
     });
     
     async function resetPassword() {
         const email = document.getElementById('forgot-password-email').value;
         const statusEl = document.getElementById('forgot-password-status');
         
         if (!email) {
             showStatus(statusEl, 'Please enter your email address', 'warning');
             return;
         }
         
         showStatus(statusEl, 'Sending password reset link...', 'info');
         
         try {
             const { error } = await supabaseClient.auth.resetPasswordForEmail(email, {
                 redirectTo: `${window.location.origin}/app/`
             });
             
             if (error) {
                 console.error('Password Reset Error:', error);
                 showStatus(statusEl, `Error: ${error.message}`, 'error');
             } else {
                 showStatus(statusEl, 'If this email is registered, a password reset link has been sent.', 'success');
                 setTimeout(() => {
                     closeForgotPasswordModal();
                 }, 3000);
             }
         } catch (e) {
             console.error('Exception during password reset:', e);
             showStatus(statusEl, `Error: ${e.message}`, 'error');
         }
     }
     
     function showUpdatePasswordModal() {
         const modal = document.getElementById('update-password-modal');
         if (modal) {
             modal.style.display = 'flex';
             document.getElementById('update-password-status').textContent = '';
             // Focus on the password input
             setTimeout(() => {
                 document.getElementById('new-password').focus();
             }, 100);
         }
     }
     
     function closeUpdatePasswordModal() {
         const modal = document.getElementById('update-password-modal');
         if (modal) {
             modal.style.display = 'none';
             document.getElementById('update-password-status').textContent = '';
             // Clear password fields for security
             document.getElementById('new-password').value = '';
             document.getElementById('confirm-password').value = '';
         }
     }
     
     // Close update password modal when clicking outside of it
     window.addEventListener('click', (event) => {
         const modal = document.getElementById('update-password-modal');
         if (event.target === modal) {
             closeUpdatePasswordModal();
         }
     });
     
     async function updatePassword() {
         const newPassword = document.getElementById('new-password').value;
         const confirmPassword = document.getElementById('confirm-password').value;
         const statusEl = document.getElementById('update-password-status');
         
         if (!newPassword || !confirmPassword) {
             showStatus(statusEl, 'Please enter both password fields', 'warning');
             return;
         }
         
         if (newPassword.length < 6) {
             showStatus(statusEl, 'Password must be at least 6 characters long', 'warning');
             return;
         }
         
         if (newPassword !== confirmPassword) {
             showStatus(statusEl, 'Passwords do not match', 'warning');
             return;
         }
         
         showStatus(statusEl, 'Updating password...', 'info');
         
         try {
             const { error } = await supabaseClient.auth.updateUser({
                 password: newPassword
             });
             
             if (error) {
                 console.error('Password Update Error:', error);
                 showStatus(statusEl, `Error: ${error.message}`, 'error');
             } else {
                 showStatus(statusEl, 'Password updated successfully!', 'success');
                 setTimeout(() => {
                     closeUpdatePasswordModal();
                     showStatus(authStatusP, 'Password updated successfully! You can now log in with your new password.', 'success', 5000);
                 }, 2000);
             }
         } catch (e) {
             console.error('Exception during password update:', e);
             showStatus(statusEl, `Error: ${e.message}`, 'error');
         }
     }

     // --- Core View Update Logic ---
     function updateContentView() {
         const isLoggedIn = !!currentSession;
         const activeTabButton = document.querySelector('.tab-button.active');
         const activeTabId = activeTabButton ? activeTabButton.id : 'tab-prompt-gen'; // Default to first tab

         console.log(`Updating view. Logged in: ${isLoggedIn}, Active Tab: ${activeTabId}`);

         // Toggle Auth vs Main App visibility
         if (authDiv) authDiv.style.display = isLoggedIn ? 'none' : 'block';
         if (mainAppContentDiv) mainAppContentDiv.style.display = isLoggedIn ? 'block' : 'none';
          
         // Hide tabs when logged out, show when logged in
         const tabBar = document.querySelector('.tab-bar');
         if (tabBar) tabBar.style.display = isLoggedIn ? 'flex' : 'none';

         // Clear status messages on view change
         showStatus(authStatusP, '');
         showStatus(purchaseStatusP, '');
         if (assetStatusP) showStatus(assetStatusP, ''); // Clear asset status too

         if (isLoggedIn) {
             // --- Logged In View ---
             if (mainAppContentDiv) mainAppContentDiv.style.display = 'block';
             if (authDiv) authDiv.style.display = 'none';

             // Show User Info Header elements
             if (purchaseControlsDiv) {
                  purchaseControlsDiv.style.display = 'flex';
                  const wrapper = purchaseControlsDiv.parentElement;
                  if(wrapper && wrapper !== userInfoContainer){ wrapper.style.display = 'flex'; }
             }
             if (currentSession.user?.email) {
                  if (userEmailDisplaySpan) userEmailDisplaySpan.innerText = currentSession.user.email;
                  if (userInfoDisplayDiv) userInfoDisplayDiv.style.display = 'inline-flex';
             } else { if (userInfoDisplayDiv) userInfoDisplayDiv.style.display = 'none'; }

             // Show the active tab content, hide others
             if (promptGenContentDiv) promptGenContentDiv.style.display = (activeTabId === 'tab-prompt-gen') ? 'block' : 'none';
             if (assetExtractionContentDiv) assetExtractionContentDiv.style.display = (activeTabId === 'tab-asset-extraction') ? 'block' : 'none';
             if (styleProfileContentDiv) styleProfileContentDiv.style.display = (activeTabId === 'tab-style-profile') ? 'block' : 'none';

             // Update credit state (shows credits, enables/disables buttons)
             updateCreditState(currentUserCredits === null ? 'loading' : currentUserCredits);

             // Manage History Button Text & Visibility
             if (activeTabId === 'tab-prompt-gen') {
                  if (historyDiv && historyButton) {
                      historyButton.innerText = historyDiv.style.display === "block" ? "Hide History" : "Show My History";
                      const currentlyLoadedCount = historyDiv.querySelectorAll('.card').length;
                      if (loadMoreContainer) loadMoreContainer.style.display = (historyDiv.style.display === "block" && currentlyLoadedCount > 0 && currentlyLoadedCount < totalHistoryItems) ? 'block' : 'none';
                  }
                   // Hide asset history if switching back to thumbnail tab
                   if(assetHistoryDisplayDiv) assetHistoryDisplayDiv.style.display = 'none';
                   if(assetHistoryLoadMoreContainer) assetHistoryLoadMoreContainer.style.display = 'none';
                   if(assetHistoryButton) assetHistoryButton.innerText = "Show My Asset History";
             } else if (activeTabId === 'tab-asset-extraction') {
                   if (assetHistoryDisplayDiv && assetHistoryButton) {
                       assetHistoryButton.innerText = assetHistoryDisplayDiv.style.display === "block" ? "Hide Asset History" : "Show My Asset History";
                       const currentlyLoadedCount = assetHistoryDisplayDiv.querySelectorAll('.asset-card').length; // Use .asset-card selector
                       if (assetHistoryLoadMoreContainer) assetHistoryLoadMoreContainer.style.display = (assetHistoryDisplayDiv.style.display === "block" && currentlyLoadedCount > 0 && currentlyLoadedCount < totalAssetHistoryItems) ? 'block' : 'none';
                   }
                   // Hide thumbnail history if switching to asset tab
                   if(historyDiv) historyDiv.style.display = 'none';
                   if(loadMoreContainer) loadMoreContainer.style.display = 'none';
                   if(historyButton) historyButton.innerText = "Show My History";
             } else if (activeTabId === 'tab-style-profile') {
                  if (historyDiv) historyDiv.style.display = 'none';
                  if (loadMoreContainer) loadMoreContainer.style.display = 'none';
                  if (historyButton) historyButton.innerText = "Show My History";
                  if (assetHistoryDisplayDiv) assetHistoryDisplayDiv.style.display = 'none';
                  if (assetHistoryLoadMoreContainer) assetHistoryLoadMoreContainer.style.display = 'none';
                  if (assetHistoryButton) assetHistoryButton.innerText = "Show My Asset History";
             }

         } else {
             // --- Logged Out View ---
             currentUserCredits = null; updateCreditState(null); // Reset credits
             selectedAssetImageDataUri = null; // Clear selected asset image

             if (mainAppContentDiv) mainAppContentDiv.style.display = 'none';
             if (authDiv) authDiv.style.display = 'block';

             // Show "How it Works" section when logged out on the Image Generation tab
             const howItWorksSection = document.getElementById('how-it-works-section');
             if (howItWorksSection) {
                 howItWorksSection.style.display = 'block';
             }

             // Optionally show signup encouragement only on the default tab when logged out
             const signupEncouragement = document.getElementById("signup-encouragement");
             if(signupEncouragement) signupEncouragement.style.display = (activeTabId === 'tab-prompt-gen') ? 'block' : 'none';

             // Hide user-specific elements
             if (userInfoDisplayDiv) userInfoDisplayDiv.style.display = 'none';
             if (purchaseControlsDiv) {
                  purchaseControlsDiv.style.display = 'none';
                  const wrapper = purchaseControlsDiv.parentElement;
                  if(wrapper && wrapper !== userInfoContainer){ wrapper.style.display = 'none'; }
             }
             if (historyDiv) historyDiv.style.display = "none";
             if (historyButton) historyButton.innerText = "Show My History";
             currentHistoryPage = 1; totalHistoryItems = 0; isLoadingHistory = false;
             currentAssetHistoryPage = 1; totalAssetHistoryItems = 0; isLoadingAssetHistory = false;
             if(historyDiv) historyDiv.innerHTML = "";
             if(assetHistoryDisplayDiv) assetHistoryDisplayDiv.innerHTML = "";
             if(loadMoreContainer) loadMoreContainer.style.display = 'none';
             if(assetHistoryLoadMoreContainer) assetHistoryLoadMoreContainer.style.display = 'none';
             if (resultDiv) resultDiv.innerHTML = "";
             if (promptPreviewDiv) promptPreviewDiv.style.display = "none";
             if (assetResultArea) assetResultArea.style.display = "none"; // Hide asset result area
             if (assetPreviewImage) assetPreviewImage.style.display = 'none'; // Hide asset preview
             if (assetPreviewPlaceholder) assetPreviewPlaceholder.style.display = 'block';


             // Show "How it Works" only on the Image Generation tab when logged out
             if(howItWorksSection) howItWorksSection.style.display = (activeTabId === 'tab-prompt-gen') ? 'block' : 'none';
         }

         // Always show the AI badge regardless of login state
         const badge = document.querySelector('.ai-badge');
         if (badge) badge.style.display = 'block';
     }


     // --- Tab Switching ---
     promptGenTabButton.addEventListener('click', () => handleTabSwitch(promptGenTabButton));
     assetExtractionTabButton.addEventListener('click', () => handleTabSwitch(assetExtractionTabButton));
     styleProfileTabButton.addEventListener('click', () => handleTabSwitch(styleProfileTabButton));

     // --- NEW: Event Listener for Option Buttons (Thumbnail Gen) ---
     if (optionsContainer) {
         optionsContainer.addEventListener('click', (event) => {
             if (event.target.classList.contains('option-button')) {
                 event.target.classList.toggle('active');
             }
         });
     } else { console.warn("Prompt options container not found."); }


     // --- API Call Logic ---

     // Generate Prompt Suggestion (Step 1 - Thumbnail Gen)
     if (form) {
         form.addEventListener('submit', async (e) => {
             e.preventDefault();
             if (!currentSession) { showStatus(authStatusP, "Please log in to get prompt suggestions.", 'warning', 3000); return; }
             if(resultDiv) resultDiv.innerHTML = "<p style='text-align:center;'>🧠 Generating prompt idea...</p>";
             if(promptPreviewDiv) promptPreviewDiv.style.display = "none";
             if(generatePromptButton) { generatePromptButton.disabled = true; generatePromptButton.innerText = "Generating..."; }
             const title = document.getElementById('title')?.value;
             const niche = document.getElementById('niche')?.value;

             const selectedOptionElements = optionsContainer ? optionsContainer.querySelectorAll('.option-button.active') : [];
             const selectedOptions = Array.from(selectedOptionElements).map(button => button.textContent.trim());
             console.log("Selected options for prompt:", selectedOptions);

             const styleProfileSelect = document.getElementById('styleProfileSelect');
            let selectedProfileJson = null; // Default to null if none selected or data missing
            if (styleProfileSelect && styleProfileSelect.value) { // Check if an option other than "-- None --" (value="") is selected
                const selectedOption = styleProfileSelect.options[styleProfileSelect.selectedIndex];
                // Check if the selected option exists and has the data attribute
                if (selectedOption && selectedOption.dataset.profileJson) { 
                    selectedProfileJson = selectedOption.dataset.profileJson; // Get the JSON string
                    console.log("Selected Profile JSON:", selectedProfileJson); 
                } else {
                    console.log("Selected dropdown option has no profile JSON data attached or attribute is missing.");
                }
            } else {
                console.log("No style profile selected from dropdown.");
            }

              try {
                  const token = currentSession.access_token;
                  const res = await fetch(`${BACKEND_URL}/prompt_suggestion`, {
                      method: "POST", 
                      headers: { 
                          "Content-Type": "application/json",
                          "Authorization": `Bearer ${token}`
                      },
                      body: JSON.stringify({ title, niche, options: selectedOptions, style_profile_json: selectedProfileJson })
                  });
                 const responseBody = await res.text(); let data;
                 try { data = JSON.parse(responseBody); } catch(e) { throw new Error(`Server returned invalid response (Status: ${res.status})`); }
                 if (!res.ok) { throw new Error(data.error || `Server error: ${res.status}`); }
                 if (data.prompt) {
                     if (resultDiv) resultDiv.innerHTML = `<p style="color:var(--success-color); text-align: center;">✅ Prompt suggestion generated!</p>`;
                      if (promptPreviewDiv) {
                          const customPromptTextarea = document.getElementById("custom-prompt");
                          if (customPromptTextarea) { customPromptTextarea.value = data.prompt; }
                          else { console.error("Textarea #custom-prompt not found!"); }
                          promptPreviewDiv.style.display = "block";
                          updateCreditState(currentUserCredits); // Update button state inside preview div
                          scrollToElement('prompt-preview');
                      } else { console.error("Div #prompt-preview not found!"); if(resultDiv) resultDiv.innerHTML += `<p style="color:var(--error-color); text-align: center;">❌ Error: UI element missing.</p>`; }
                 } else { throw new Error('AI did not return a prompt.'); }
             } catch (err) {
                 console.error("Prompt Generation Error:", err);
                 if(resultDiv) resultDiv.innerHTML = `<p style="color:var(--error-color); text-align: center;">❌ Error Generating Prompt: ${err.message}</p>`;
                 if (promptPreviewDiv) promptPreviewDiv.style.display = "none";
             } finally { if(generatePromptButton) { generatePromptButton.disabled = false; generatePromptButton.innerText = "Suggest Prompt Idea"; }}
         });
     } else { console.warn("Thumbnail form not found."); }


     // --- Image Preview Modal Helper ---
     function showModal(src){
         const modal=document.getElementById('img-modal');
         const modalImg = modal ? modal.querySelector('img') : null;
         if (!modal || !modalImg || !src) return; // Add safety check for src
         modalImg.src=src;
         modal.style.display='flex';
     }


     // Generate Thumbnails (Step 2 - Confirm Prompt - Thumbnail Gen)
     async function confirmPrompt() {
         const promptInput = document.getElementById("custom-prompt");
         const prompt = promptInput ? promptInput.value : null;
         if (!prompt || !prompt.trim()) { showStatus(creditWarningP, "Please enter a prompt describing the thumbnail.", 'warning', 3000); scrollToElement('custom-prompt'); return; }
         if (!currentSession) { showStatus(authStatusP, "Please log in to generate thumbnails.", 'warning', 3000); scrollToElement('auth'); return; }
          const creditsTargetElement = creditsContainer.closest('.user-info-container > div') || creditsContainer;
          if (currentUserCredits === null || currentUserCredits < TOTAL_GENERATION_COST) { scrollToElement(creditsTargetElement.id || 'credits-container'); return; }

         if (resultDiv) resultDiv.innerHTML = `<p style="text-align: center;">🎨 Generating ${NUM_IMAGES_EXPECTED} thumbnails... (Cost: ${TOTAL_GENERATION_COST} credits). It can take up to a minute. Please wait.</p>`;
         if (promptPreviewDiv) promptPreviewDiv.style.display = "none";
         if (confirmPromptButton) { confirmPromptButton.disabled = true; confirmPromptButton.innerText = "Generating..."; }
         const title = document.getElementById("title")?.value;
         const niche = document.getElementById("niche")?.value;
         const styleProfileSelect = document.getElementById('styleProfileSelect');
         let selectedStyleJson = null;

         if (styleProfileSelect && styleProfileSelect.value) {
             try {
                 selectedStyleJson = JSON.parse(styleProfileSelect.options[styleProfileSelect.selectedIndex].dataset.profileJson);
                 console.log("Selected Style Profile JSON:", selectedStyleJson);
             } catch (e) {
                 console.error("Error parsing stored style profile JSON:", e);
                 showStatus(creditWarningP, 'Error retrieving selected style profile data.', 'error', 3000);
                 return; // Stop if the stored data is corrupt
             }
         }

         try {
             const token = currentSession.access_token;
             const res = await fetch(`${BACKEND_URL}/generate`, {
                 method: "POST", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${token}` },
                 body: JSON.stringify({ title, niche, prompt, style_profile_json: selectedStyleJson })
             });
             const responseBody = await res.text(); let data;
             try { data = JSON.parse(responseBody); } catch (e) { throw new Error(`Server returned non-JSON response (Status: ${res.status})`); }
             if (!res.ok) {
                 if (res.status === 401) throw new Error("Authentication error.");
                 if (res.status === 403 && data.error?.includes("Insufficient credits")) throw new Error(data.error);
                 if (res.status === 0) { throw new Error("NetworkError when attempting to fetch resource."); }
                 throw new Error(data.error || `Server error: ${res.status}`);
             }
             if (data.image_urls && Array.isArray(data.image_urls) && data.image_urls.length > 0 && resultDiv) {
                  resultDiv.innerHTML = `<h2>Generated Thumbnails:</h2>`;
                  const gridDiv = document.createElement('div'); gridDiv.className = 'thumbnail-results-grid';
                  let displayedImages = 0;
                  data.image_urls.forEach((imageUrl, index) => {
                      if (imageUrl && (imageUrl.startsWith('data:image') || imageUrl.startsWith('http'))) {
                          displayedImages++;
                          const itemDiv = document.createElement('div'); itemDiv.className = 'thumbnail-item';
                          const img = document.createElement('img'); img.src = imageUrl; img.alt = `Generated Thumbnail Option ${index + 1}`;
                          img.onclick = () => showModal(imageUrl);
                          img.onerror = () => { img.alt = 'Error loading image'; }
                          const button = document.createElement('button');
                          const downloadFilename = `${title || 'thumbnail'}_${index + 1}`;
                          button.innerText = `⬇ Download Option ${index + 1}`;
                          button.onclick = () => downloadImage(imageUrl, downloadFilename);
                          itemDiv.appendChild(img); itemDiv.appendChild(button);
                          gridDiv.appendChild(itemDiv);
                      } else {
                          console.warn(`Received invalid image URL at index ${index}:`, imageUrl);
                          const itemDiv = document.createElement('div'); itemDiv.className = 'thumbnail-item';
                          itemDiv.innerHTML = `<p style="color:var(--warning-color); text-align: center; padding: 2rem 0;">⚠️ Image ${index + 1} failed.</p>`;
                          gridDiv.appendChild(itemDiv);
                      }
                  });
                  resultDiv.appendChild(gridDiv);
                  resultDiv.insertAdjacentHTML('beforeend', `<div class="prompt-text"><strong>Prompt Used:</strong><br>${data.prompt || prompt}</div>`);
                  scrollToElement('result');
                  
                  // We don't update the carousel with newly generated thumbnails anymore
                  // Carousel now shows curated showcase thumbnails for all users
                  
                  if (data.new_credits !== undefined) { updateCreditState(data.new_credits); }
                  else { fetchUserCredits(); } // Fallback if backend doesn't return new credits
                  if (displayedImages < NUM_IMAGES_EXPECTED) { showStatus(resultDiv, `Generated ${displayedImages}/${NUM_IMAGES_EXPECTED} images successfully.`, 'warning', 5000); }
              } else { throw new Error('Received invalid image data from server.'); }
         } catch (err) {
             console.error("Image Generation Error:", err);
             if(resultDiv) resultDiv.innerHTML = `<p style="color:var(--error-color); text-align: center;">❌ Generation Failed: ${err.message}</p>`;
             if(promptPreviewDiv) promptPreviewDiv.style.display = "block"; // Show prompt box again even on error
             if (err.message.includes("Insufficient credits")) { await fetchUserCredits(); scrollToElement(creditsTargetElement.id || 'credits-container'); }
             else if (err.message.includes("Authent")) await logout();
             else { updateCreditState(currentUserCredits); } // Refresh credit state but keep current value
         } finally {
             if(confirmPromptButton) {
                  confirmPromptButton.disabled = false;
                  updateCreditState(currentUserCredits); // Ensure button text/state reflects current credits
             }
         }
     }


     // --- History Fetch (Thumbnails) ---
     async function fetchHistory(loadMore = false) {
         if (isLoadingHistory && loadMore) return;
         if (!currentSession) { showStatus(authStatusP, "Log in to view history.", 'warning', 3000); if(historyDiv) historyDiv.style.display = "none"; if (loadMoreContainer) loadMoreContainer.style.display = 'none'; return; }
         if (!historyDiv || !historyButton) { console.warn("History elements not found."); return; }

         if (!loadMore) {
             if (historyDiv.style.display === "block") { historyDiv.style.display = "none"; historyButton.innerText = "Show My History"; if (loadMoreContainer) loadMoreContainer.style.display = 'none'; return; }
             else { currentHistoryPage = 1; totalHistoryItems = 0; historyDiv.innerHTML = "<p>📦 Loading history...</p>"; historyDiv.style.display = "block"; historyButton.innerText = "Fetching..."; if (loadMoreContainer) loadMoreContainer.style.display = 'none'; }
         } else { if (loadMoreButton) { loadMoreButton.disabled = true; loadMoreButton.innerText = "Loading..."; } }
         isLoadingHistory = true; historyButton.disabled = true;

         try {
             const token = currentSession.access_token;
             const fetchUrl = `${BACKEND_URL}/history?page=${currentHistoryPage}&limit=${HISTORY_ITEMS_PER_PAGE}`;
             const res = await fetch(fetchUrl, { method: "GET", headers: { "Authorization": `Bearer ${token}` } });
             const responseBody = await res.text(); let data;
             try { data = JSON.parse(responseBody); } catch(e) { throw new Error(`Server returned invalid history response (Status: ${res.status})`); }
             if (res.status === 401) throw new Error("Authentication error.");
             if (!res.ok) { throw new Error(data.error || `Server error fetching history: ${res.status}`); }
             const items = data.items || []; totalHistoryItems = data.total || 0;

             if (currentHistoryPage === 1) {
                 historyDiv.innerHTML = ""; // Clear loading message or previous content
                 if (items.length === 0 && totalHistoryItems === 0) { historyDiv.innerHTML = "<h2>History</h2><p>🕸️ No thumbnails generated yet.</p>"; }
                 else if (items.length > 0 || totalHistoryItems > 0) { historyDiv.innerHTML = `<h2>History (${totalHistoryItems} total)</h2>`; }
             }

             const itemsHtml = items.map(item => {
                 const displayImageUrl = item.preview_image_url || item.image_url || '';
                 const fullImageUrl    = item.image_url;
                 const canClickPreview = displayImageUrl && (displayImageUrl.startsWith('data:image') || displayImageUrl.startsWith('http'));
                 const showDownload    = fullImageUrl && (fullImageUrl.startsWith('data:image') || fullImageUrl.startsWith('http'));
                 const generatedDate   = item.created_at ? new Date(item.created_at).toLocaleString() : 'N/A';
                 const maxPromptLength = 100;
                 const displayPrompt   = (item.prompt && item.prompt.length > maxPromptLength) ? item.prompt.substring(0, maxPromptLength) + '…' : (item.prompt || 'N/A');
                 const safeTitle       = (item.title || 'thumbnail').replace(/[^a-z0-9_]/gi, '_').toLowerCase();

                 return `
                   <div class="card">
                        ${displayImageUrl ? `<img src="${displayImageUrl}" alt="Thumbnail Preview: ${item.title || 'Untitled'}" ${canClickPreview ? `onclick="showModal('${fullImageUrl || displayImageUrl}')"` : ''} style="${canClickPreview ? '' : 'cursor:default;'}" onerror="this.alt='Error loading preview'; this.nextElementSibling?.remove();">` : '<p style="text-align:center; padding: 2rem 0; color: var(--text-muted);">⚠️ Image unavailable</p>'}
                        ${showDownload ? `<button onclick="downloadImage('${fullImageUrl}','${safeTitle}')" class="secondary-button">⬇ Download</button>` : ''}
                        <p><strong>Title:</strong> ${item.title || 'N/A'}</p>
                        <p><strong>Niche:</strong> ${item.niche || 'N/A'}</p>
                        <p><strong>Prompt:</strong> ${displayPrompt}</p>
                        <p class="timestamp">Generated: ${generatedDate}</p>
                   </div>`;
             }).join('');

             historyDiv.insertAdjacentHTML('beforeend', itemsHtml);
             const currentlyLoadedCount = historyDiv.querySelectorAll('.card').length;
             
             // We don't update the carousel with history items anymore
             // Carousel now shows curated showcase thumbnails for all users
             
             if (loadMoreContainer) {
                 if (items.length > 0 && currentlyLoadedCount < totalHistoryItems) {
                     loadMoreContainer.style.display = 'block';
                     if (loadMoreButton) { loadMoreButton.disabled = false; loadMoreButton.innerText = "Load More History"; }
                     currentHistoryPage++;
                 } else {
                     loadMoreContainer.style.display = 'none';
                     if (currentlyLoadedCount > 0 && currentHistoryPage > 1 && currentlyLoadedCount >= totalHistoryItems) {
                          if (!historyDiv.querySelector('.no-more-history')) { historyDiv.insertAdjacentHTML('beforeend', '<p class="no-more-history">-- End of History --</p>'); }
                     }
                 }
             }
         } catch (err) {
             console.error("Error fetching history:", err);
             if (currentHistoryPage === 1 && historyDiv) { historyDiv.innerHTML = `<p style="color:var(--error-color);">❌ Error fetching history: ${err.message}</p>`; historyDiv.style.display = "block"; }
             else { /* Handle load more error display if needed */ }
             if (err.message.includes("Authent")) await logout();
         } finally {
             isLoadingHistory = false; if(historyButton) historyButton.disabled = false;
             if (historyDiv && historyButton) historyButton.innerText = historyDiv.style.display === "block" ? "Hide History" : "Show My History";
              if (loadMoreButton && loadMoreContainer && loadMoreContainer.style.display === 'block') { loadMoreButton.disabled = false; loadMoreButton.innerText = "Load More History"; }
         }
     }
     // NOTE: history load more button listener is outside DOMContentLoaded


     // --- NEW: Asset Extraction File Input Handling ---
     if (assetSourceImageInput) {
         assetSourceImageInput.addEventListener('change', (event) => {
             const file = event.target.files[0];
             selectedAssetImageDataUri = null; // Reset previous selection
             if (assetPreviewImage) assetPreviewImage.style.display = 'none';
             if (assetPreviewPlaceholder) assetPreviewPlaceholder.style.display = 'block';
             if (assetResultArea) assetResultArea.style.display = 'none'; // Hide previous result
             if (assetStatusP) showStatus(assetStatusP, ''); // Clear previous status
             updateCreditState(currentUserCredits); // Update button state

             if (file) {
                 // Check if file type is allowed (PNG, JPG, JPEG)
                 if (file.type !== 'image/png' && file.type !== 'image/jpeg' && file.type !== 'image/jpg') {
                     showStatus(assetStatusP, 'Invalid file type. Please select a PNG or JPG/JPEG image.', 'error', 5000);
                     assetSourceImageInput.value = ''; // Clear the input
                     return;
                 }

                 const reader = new FileReader();
                 reader.onload = (e) => {
                     selectedAssetImageDataUri = e.target.result;
                     if (assetPreviewImage) {
                         assetPreviewImage.src = selectedAssetImageDataUri;
                         assetPreviewImage.style.display = 'block';
                     }
                     if (assetPreviewPlaceholder) assetPreviewPlaceholder.style.display = 'none';
                     updateCreditState(currentUserCredits); // Update button state now that image is loaded
                 }
                 reader.onerror = (e) => {
                     console.error("FileReader error:", e);
                     showStatus(assetStatusP, 'Error reading the selected file.', 'error', 5000);
                     selectedAssetImageDataUri = null;
                      assetSourceImageInput.value = '';
                      updateCreditState(currentUserCredits);
                 }
                 reader.readAsDataURL(file);
             }
         });
     } else { console.warn("Asset source image input not found."); }

     // --- NEW: Asset Description Input Handling ---
     if (assetDescriptionInput) {
         assetDescriptionInput.addEventListener('input', () => {
             // Update button state whenever description changes
             updateCreditState(currentUserCredits);
         });
     }

     // --- NEW: Extract Asset API Call ---
     async function extractAsset() {
         if (!currentSession) { showStatus(authStatusP, "Please log in to extract assets.", 'warning', 3000); scrollToElement('auth'); return; }
         if (!selectedAssetImageDataUri) { showStatus(assetStatusP, 'Please select a PNG image first.', 'warning', 3000); return; }
         const description = assetDescriptionInput ? assetDescriptionInput.value.trim() : null;
         if (!description) { showStatus(assetStatusP, 'Please describe the asset you want to extract.', 'warning', 3000); scrollToElement('asset-description'); return; }
         const creditsTargetElement = creditsContainer ? creditsContainer.closest('.user-info-container > div') : null;
          if (currentUserCredits === null || currentUserCredits < CREDIT_COST_PER_ASSET_EXTRACTION) {
             showStatus(assetStatusP, `Insufficient credits. You need ${CREDIT_COST_PER_ASSET_EXTRACTION}.`, 'error', 4000);
             scrollToElement(creditsTargetElement?.id || 'credits-container');
             return;
          }

         if (assetStatusP) showStatus(assetStatusP, '⏳ Extracting asset... This might take a minute.', 'info');
         if (extractAssetButton) { extractAssetButton.disabled = true; extractAssetButton.innerText = "Extracting..."; }
         if (assetResultArea) assetResultArea.style.display = 'none'; // Hide previous result

         try {
             const token = currentSession.access_token;
             const res = await fetch(`${BACKEND_URL}/extract_asset`, {
                 method: "POST", 
                 headers: { 
                     "Content-Type": "application/json",
                     "Authorization": `Bearer ${token}`
                 },
                 // Only send the required parameters for asset extraction
                 body: JSON.stringify({ 
                     image_data_uri: selectedAssetImageDataUri,
                     asset_description: description
                 }) 
             });

             const responseBody = await res.text(); let data;
             try { data = JSON.parse(responseBody); } catch (e) { throw new Error(`Server returned non-JSON response (Status: ${res.status})`); }

             if (!res.ok) {
                 if (res.status === 401) throw new Error("Authentication error.");
                 if (res.status === 403 && data.error?.includes("Insufficient credits")) throw new Error(data.error);
                 // Handle specific DALL-E content policy error
                 if (res.status === 400 && data.error?.includes("content policy violation")) {
                     throw new Error("Extraction failed: The request violated the AI's content policy.");
                 }
                 if (res.status === 0) { throw new Error("NetworkError when attempting to fetch resource."); }
                 throw new Error(data.error || `Asset extraction failed (Status: ${res.status})`);
             }

             if (data.result_png_uri && data.result_png_uri.startsWith('data:image/png')) {
                 if (assetResultImage) {
                     assetResultImage.src = data.result_png_uri;
                     assetResultImage.onclick = () => showModal(data.result_png_uri);
                     assetResultImage.onerror = () => {
                         assetResultImage.alt = 'Error loading extracted image preview';
                         // Optionally add a visible error message if preview fails
                         console.error("Error loading asset preview image.");
                         // You could add text here like: previewContainer.innerHTML = "<p>Preview failed</p>";
                     };
                     assetResultImage.style.display = 'block';
                 } else { console.warn("Asset result image element not found."); }

                 if (assetResultContainer) assetResultContainer.style.display = 'flex'; // Make sure container is visible

                 if (assetDownloadButton) {
                     assetDownloadButton.onclick = () => downloadImage(data.result_png_uri, `extracted_${description.replace(/[^a-z0-9_]/gi, '_').toLowerCase() || 'asset'}`);
                     assetDownloadButton.style.display = 'inline-block';
                 } else { console.warn("Asset download button element not found."); }

                 if (assetResultArea) assetResultArea.style.display = 'block'; // Show the results area

                 if (assetStatusP) showStatus(assetStatusP, '✅ Asset extracted successfully!', 'success', 5000);
                 scrollToElement('asset-result-area');

                 if (data.new_credits !== undefined) {
                     updateCreditState(data.new_credits);
                 } else {
                     fetchUserCredits(); // Fetch credits if backend didn't return them
                 }
             } else {
                 // It's possible the b64_json was empty/invalid from the start
                 console.error("Received success status but invalid/missing 'result_png_uri'."); // Use console.error
                 throw new Error('AI did not return valid image data.');
             }

         } catch (err) {
             console.error("Asset Extraction Error:", err);
             if(assetStatusP) showStatus(assetStatusP, `❌ Extraction Failed: ${err.message}`, 'error');
             if (err.message.includes("Insufficient credits")) { await fetchUserCredits(); scrollToElement(creditsTargetElement?.id || 'credits-container'); }
             else if (err.message.includes("Authent")) { await logout(); }
             else { updateCreditState(currentUserCredits); } // Refresh credit state but keep current value
         } finally {
             if (extractAssetButton) {
                 // Re-enable button based on current state after API call
                 updateCreditState(currentUserCredits);
             }
         }
     }
     // Attach listener to the button
     if (extractAssetButton) { extractAssetButton.addEventListener('click', extractAsset); }

     // --- UPDATED Asset History Fetch Function ---
     async function fetchAssetHistory(loadMore = false) {
        // Keep initial logs for checking if function starts
        console.log("FETCH ASSET HISTORY STARTING - loadMore:", loadMore); // Changed to console.log
        console.log("isLoadingAssetHistory:", isLoadingAssetHistory, "currentSession:", !!currentSession);

        // --- Initial Checks ---
        if (isLoadingAssetHistory && loadMore) {
            console.log("Exiting: Already loading more history.");
            return;
        }
        if (!currentSession) { console.error("Exiting fetchAssetHistory: No current session."); showStatus(authStatusP, "Log in to view asset history.", 'warning', 3000); if (assetHistoryDisplayDiv) assetHistoryDisplayDiv.style.display = "none"; if (assetHistoryLoadMoreContainer) assetHistoryLoadMoreContainer.style.display = 'none'; if (assetHistoryButton) assetHistoryButton.innerText = "Show My Asset History"; return; }
        // Ensure DOM elements exist
        if (!assetHistoryDisplayDiv || !assetHistoryButton || !assetHistoryLoadMoreContainer || !assetHistoryLoadMoreButton) {
            console.error("CRITICAL: Asset history DOM elements not found! Check IDs: asset-history-display, asset-history-button, asset-history-load-more-container, asset-history-load-more-button");
            showStatus(assetStatusP || authStatusP, "UI Error: History elements missing.", 'error', 5000);
            if(assetHistoryButton) assetHistoryButton.innerText = "Show My Asset History"; // Reset button text if possible
            return;
        }

        console.log("Proceeding to fetch/toggle history display.");

        // --- Button State & Toggle Logic ---
        assetHistoryButton.disabled = true; // Disable main button during operation

        if (!loadMore) {
            // This is the first click on "Show My Asset History"
            if (assetHistoryDisplayDiv.style.display === "block") {
                // If already visible, hide it
                console.log("Toggling history OFF");
                assetHistoryDisplayDiv.style.display = "none";
                assetHistoryButton.innerText = "Show My Asset History";
                assetHistoryLoadMoreContainer.style.display = 'none';
                assetHistoryButton.disabled = false; // Re-enable button
                return; // Exit function
            } else {
                // If hidden, prepare to show (set loading message but DON'T set display:block yet)
                console.log("Toggling history ON - preparing for fetch.");
                currentAssetHistoryPage = 1;
                totalAssetHistoryItems = 0;
                assetHistoryDisplayDiv.innerHTML = "<p>📦 Loading asset history...</p>"; // Show loading message
                // NOTE: display: block is now set AFTER fetch succeeds
                assetHistoryButton.innerText = "Fetching..."; // Update button text while loading
                assetHistoryLoadMoreContainer.style.display = 'none'; // Hide load more initially
            }
        } else {
            // This is a click on "Load More"
            console.log("Loading more history...");
            assetHistoryLoadMoreButton.disabled = true;
            assetHistoryLoadMoreButton.innerText = "Loading...";
            // Keep main button disabled
        }

        isLoadingAssetHistory = true; // Flag that we are loading

        // --- Fetch Data ---
        try {
            const token = currentSession.access_token;
            const fetchUrl = `${BACKEND_URL}/asset_history?page=${currentAssetHistoryPage}&limit=${ASSET_HISTORY_ITEMS_PER_PAGE}`;
            console.log(`Workspaceing asset history from: ${fetchUrl}`); // Changed log prefix

            const res = await fetch(fetchUrl, { method: "GET", headers: { "Authorization": `Bearer ${token}` } });
            console.log(`Workspace response status: ${res.status}`); // Changed log prefix

            const responseBody = await res.text();
            let data;
            try {
                data = JSON.parse(responseBody);
            } catch (err) {
                console.error("Failed to parse JSON response:", responseBody);
                throw new Error(`Server returned invalid asset history response (Status: ${res.status})`);
            }

            // Handle HTTP errors
            if (res.status === 401) throw new Error("Authentication error.");
            if (!res.ok) { throw new Error(data.error || `Server error fetching asset history: ${res.status}`); }
            const items = data.items || []; totalAssetHistoryItems = data.total || 0;
            console.log(`Received ${items.length} items. Total items: ${totalAssetHistoryItems}`);

            // ---> Make the container visible NOW, just before adding content <---
            assetHistoryDisplayDiv.style.display = "block";

            // --- Prepare Display Area (Page 1 Only) ---
            if (currentAssetHistoryPage === 1) {
                assetHistoryDisplayDiv.innerHTML = ""; // Clear loading message
                // Add Heading
                const heading = document.createElement('h2');
                heading.textContent = `Asset History (${totalAssetHistoryItems} total)`;
                assetHistoryDisplayDiv.appendChild(heading);
                // Handle case where history is empty
                if (items.length === 0 && totalAssetHistoryItems === 0) { assetHistoryDisplayDiv.innerHTML = `<h2>Asset History</h2><p>✂️ No assets extracted yet.</p>`; }
                else if (items.length > 0 || totalAssetHistoryItems > 0) { assetHistoryDisplayDiv.innerHTML = `<h2>Asset History (${totalAssetHistoryItems} total)</h2>`; }
            }

            // --- Render History Items (Simplified Look) ---
            if (items.length > 0) {
                const itemsHtml = items.map(item => {
                    const extractedPreviewUrl = item.extracted_asset_preview_url || '';
                    const extractedFullUrl = item.extracted_asset_url || ''; // Full URI for download/modal

                    // Only show extracted asset preview
                    const extractedImgHtml = extractedPreviewUrl.startsWith('data:image')
                        ? `<img src="${extractedPreviewUrl}" alt="Extracted Asset Preview" style="cursor:pointer;" onclick="showModal('${extractedFullUrl || extractedPreviewUrl}')">`
                        : '<p style="font-size:0.8em; color:var(--text-muted);">Extracted Preview N/A</p>';

                    // Download button logic
                    const canDownload = extractedFullUrl.startsWith('data:image/png');
                    const safeDescription = (item.asset_description || 'asset').replace(/[^a-z0-9_]/gi, '_').toLowerCase();
                    const downloadFilename = `extracted_${safeDescription}_${item.id || Date.now()}`;
                    const downloadButtonHtml = canDownload
                        ? `<button onclick="downloadImage('${extractedFullUrl}','${downloadFilename}')" class="secondary-button">⬇ Download</button>`
                        : '';

                    const generatedDate = item.created_at ? new Date(item.created_at).toLocaleString() : 'N/A';

                    // Simplified card structure: Image centered above text/button
                    return `
                        <div class="asset-card">
                             <div class="asset-card-preview-container">
                                ${extractedImgHtml}
                             </div>
                             <p><strong>Description:</strong> ${item.asset_description || 'N/A'}</p>
                             <p class="timestamp">Generated: ${generatedDate}</p>
                             ${downloadButtonHtml}
                        </div>`;
                }).join('');

                assetHistoryDisplayDiv.insertAdjacentHTML('beforeend', itemsHtml);
                const currentlyLoadedCount = assetHistoryDisplayDiv.querySelectorAll('.asset-card').length;
                console.log("Currently loaded asset card count:", currentlyLoadedCount);

                if (assetHistoryLoadMoreContainer) {
                    if (items.length > 0 && currentlyLoadedCount < totalAssetHistoryItems) {
                        // Show "Load More" button if there are more items to load
                        assetHistoryLoadMoreContainer.style.display = 'block';
                        if (assetHistoryLoadMoreButton) {
                            assetHistoryLoadMoreButton.disabled = false;
                            assetHistoryLoadMoreButton.innerText = "Load More Asset History";
                        }
                        currentAssetHistoryPage++; // Increment page number for the next fetch
                    } else {
                        assetHistoryLoadMoreContainer.style.display = 'none';
                        // Add "End of History" message if appropriate
                        if (currentlyLoadedCount > 0 && currentlyLoadedCount >= totalAssetHistoryItems) {
                            if (!assetHistoryDisplayDiv.querySelector('.no-more-history')) {
                                const endMsg = document.createElement('p');
                                endMsg.className = 'no-more-history'; // Use class for styling
                                endMsg.textContent = '-- End of Asset History --';
                                assetHistoryDisplayDiv.appendChild(endMsg);
                            }
                        }
                    }
                }
            }
            console.log("FETCH ASSET HISTORY FINISHED TRY BLOCK successfully.");

        } catch (err) {
            // --- Error Handling ---
            console.error("FETCH ASSET HISTORY CAUGHT ERROR:", err);
            if (currentAssetHistoryPage === 1 && assetHistoryDisplayDiv) {
                // Show error message only if it's the first page load attempt
                assetHistoryDisplayDiv.innerHTML = `<h2>Asset History</h2><p style="color:var(--error-color);">❌ Error fetching asset history: ${err.message}</p>`;
                assetHistoryDisplayDiv.style.display = "block"; // Ensure div is visible to show error
            } else if (assetHistoryDisplayDiv){
                // Optionally show error near load more button if loading more fails
                 showStatus(assetHistoryLoadMoreContainer || assetStatusP, `Error loading more: ${err.message}`, 'error', 4000);
            }
            // Handle specific errors
            if (err.message.includes("Authent")) await logout();
            // Ensure button text is reset even on error for the main button
            if (assetHistoryButton) assetHistoryButton.innerText = "Show My Asset History";

        } finally {
            // --- Cleanup & Final Button State ---
            console.log("FETCH ASSET HISTORY FINALLY BLOCK");
            isLoadingAssetHistory = false; // Reset loading flag

            // Reset main history button state based on final visibility
            if (assetHistoryButton) {
                assetHistoryButton.disabled = false; // Always re-enable main button
                if (assetHistoryDisplayDiv) {
                     // Set text based on whether the div ended up visible or not
                    assetHistoryButton.innerText = assetHistoryDisplayDiv.style.display === "block" ? "Hide Asset History" : "Show My Asset History";
                } else {
                    assetHistoryButton.innerText = "Show My Asset History"; // Fallback
                }
            }

            // Ensure Load More button is correctly enabled/disabled if it's visible
            if (assetHistoryLoadMoreButton && assetHistoryLoadMoreContainer && assetHistoryLoadMoreContainer.style.display === 'block') {
                assetHistoryLoadMoreButton.disabled = false;
                assetHistoryLoadMoreButton.innerText = "Load More Asset History";
            } else if (assetHistoryLoadMoreButton) {
                // Ensure it's disabled if the container is hidden
                assetHistoryLoadMoreButton.disabled = true;
            }
            console.log("FETCH ASSET HISTORY FINISHED FINALLY BLOCK.");
        }
    }
     // Attach listeners for asset history buttons (Done in DOMContentLoaded)


     // --- Download Image Utility ---
     function downloadImage(url, baseFilename = 'download') {
         // Find the button that triggered this (if any) to show errors nearby
         const buttons = document.querySelectorAll('button'); let downloadButton = null;
         buttons.forEach(btn => { if (btn.onclick && btn.onclick.toString().includes(url.substring(0, 50))) { downloadButton = btn; } });
         // Determine where to show error messages (near button or in a general area)
         const parentElement = downloadButton ? downloadButton.closest('.thumbnail-item, .card, .asset-card, .asset-result-actions') : (resultDiv || assetResultArea);
         let errorTarget = parentElement || resultDiv || assetResultArea || document.body; // Fallback target
          // Clear previous error messages in the target area
          const existingError = errorTarget.querySelector('.download-error-message');
          if (existingError) existingError.remove();

          if (!url) {
              console.error("Download failed: URL is missing.");
              const errorP = document.createElement('p'); errorP.className = 'download-error-message';
              errorP.innerText = `Download failed: Image data missing or invalid.`;
              errorTarget.appendChild(errorP); // Append error to the determined target
              return;
          }

          // Handle different types of URLs
          if (url.startsWith('data:image') || url.startsWith('blob:')) {
              // Data URI or Blob URL - can download directly
              handleDirectDownload(url, baseFilename, errorTarget);
          } else if (url.startsWith('http://') || url.startsWith('https://')) {
              // HTTP/HTTPS URL - need to fetch and convert to blob
              handleRemoteImageDownload(url, baseFilename, errorTarget);
          } else {
              console.error("Download failed: Unsupported URL format.", url);
              const errorP = document.createElement('p'); errorP.className = 'download-error-message';
              errorP.innerText = `Download failed: Unsupported image format.`;
              errorTarget.appendChild(errorP);
          }
     }

     // Helper function for direct downloads (data URIs and blob URLs)
     function handleDirectDownload(url, baseFilename, errorTarget) {
          const safeFilename = baseFilename.replace(/[^a-z0-9_.\-]/gi, '_').toLowerCase() || 'download'; // Allow dots and hyphens
          let extension = 'png'; // Default extension
          if (url.startsWith('data:image')) {
              const formatMatch = url.match(/^data:image\/([a-zA-Z+]+);base64,/);
              extension = formatMatch ? formatMatch[1].replace('+', '').toLowerCase() : 'png';
              // Handle jpeg vs jpg
              if (extension === 'jpeg') extension = 'jpg';
          }
          // Ensure filename has the correct extension
          const filename = safeFilename.endsWith('.' + extension) ? safeFilename : `${safeFilename}.${extension}`;

          try {
              const link = document.createElement("a"); link.href = url; link.download = filename;
              document.body.appendChild(link); link.click(); document.body.removeChild(link);
              console.log(`Download initiated for: ${filename}`);
          } catch (err) {
              console.error("Download failed via link click:", err);
              const errorP = document.createElement('p'); errorP.className = 'download-error-message';
              errorP.innerText = `Download failed (${err.message}). Try right-clicking the image > 'Save Image As...'.`;
              errorTarget.appendChild(errorP);
          }
     }

     // Helper function for remote image downloads (HTTP/HTTPS URLs)
     function handleRemoteImageDownload(url, baseFilename, errorTarget) {
          const statusP = document.createElement('p');
          statusP.className = 'download-error-message';
          statusP.style.color = 'var(--text-muted)';
          statusP.innerText = 'Preparing download...';
          errorTarget.appendChild(statusP);

          // Fetch the image and convert to blob
          fetch(url, { 
              method: 'GET',
              headers: {
                  // Add cache control to avoid CORS issues
                  'Cache-Control': 'no-cache',
                  'Pragma': 'no-cache'
              },
              mode: 'cors' // Try CORS mode
          })
          .then(response => {
              if (!response.ok) {
                  throw new Error(`HTTP error! status: ${response.status}`);
              }
              return response.blob();
          })
          .then(blob => {
              // Create a blob URL and download
              const blobUrl = URL.createObjectURL(blob);
              
              // Get extension from content type or URL
              let extension = 'png'; // Default
              const contentType = blob.type;
              if (contentType) {
                  const match = contentType.match(/image\/([a-zA-Z+]+)/);
                  if (match) {
                      extension = match[1].toLowerCase();
                      if (extension === 'jpeg') extension = 'jpg';
                  }
              } else if (url.includes('.')) {
                  // Try to get extension from URL
                  const urlExt = url.split('.').pop().toLowerCase();
                  if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(urlExt)) {
                      extension = urlExt;
                  }
              }
              
              // Create safe filename
              const safeFilename = baseFilename.replace(/[^a-z0-9_.\-]/gi, '_').toLowerCase() || 'download';
              const filename = safeFilename.endsWith('.' + extension) ? safeFilename : `${safeFilename}.${extension}`;
              
              // Download the blob
              const link = document.createElement('a');
              link.href = blobUrl;
              link.download = filename;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              
              // Clean up
              URL.revokeObjectURL(blobUrl);
              statusP.remove();
              console.log(`Download completed for: ${filename}`);
          })
          .catch(error => {
              console.error('Error downloading image:', error);
              statusP.style.color = 'var(--error-color)';
              statusP.innerText = `Download failed: ${error.message}. Try right-clicking the image and selecting 'Save Image As...'`;
          });
     }


     // --- Scroll Utility ---
      function scrollToElement(elementId) {
          let element;
          if (typeof elementId === 'string') { element = document.getElementById(elementId); }
          else if (elementId instanceof Element) { element = elementId; }

          if (element) {
              element.scrollIntoView({ behavior: 'smooth', block: 'center' });
              // Optional highlight effect
              const elementIdentifier = element.id || '';
              const parentWrapper = element.closest('.user-info-container > div');
              const highlightTarget = parentWrapper || element;
               // Apply highlight to specific interactive areas or results
               if (['auth', 'credit-warning', 'custom-prompt', 'result', 'credits-container', 'asset-description', 'asset-result-area'].includes(elementIdentifier) || parentWrapper) {
                   highlightTarget.style.transition = 'background-color 0.5s ease-in-out, box-shadow 0.5s ease-in-out';
                   const highlightColor = ['result', 'asset-result-area'].includes(elementIdentifier) ? 'rgba(167, 139, 250, 0.05)' : 'rgba(167, 139, 250, 0.1)';
                   highlightTarget.style.backgroundColor = highlightColor;
                   highlightTarget.style.boxShadow = '0 0 15px rgba(167, 139, 250, 0.3)';
                   setTimeout(() => {
                       highlightTarget.style.backgroundColor = '';
                       highlightTarget.style.boxShadow = '';
                   }, 1500);
               }
           } else { console.warn(`scrollToElement: Element not found for identifier:`, elementId); }
      }


     // --- Style Profile Functions ---
     // Store uploaded thumbnails
     let uploadedThumbnails = [];
     const MAX_THUMBNAILS = 5;
     
     // Initialize style profile functionality
     function initStyleProfile() {
         if (styleThumbnailsUpload) {
             styleThumbnailsUpload.addEventListener('change', handleThumbnailUpload);
         }
         
         if (analyzeStyleButton) {
             analyzeStyleButton.addEventListener('click', analyzeStyle);
         }
         
         if (saveStyleButton) {
             saveStyleButton.addEventListener('click', saveStyleProfile);
         }
         
         // Load saved styles from Supabase
         loadSavedStyles();
     }
     
     // Handle thumbnail upload
     function handleThumbnailUpload(e) {
         const files = e.target.files;
         if (!files || files.length === 0) return;
         
         // Check if adding these files would exceed the limit
         if (uploadedThumbnails.length + files.length > MAX_THUMBNAILS) {
             showStatus(styleAnalysisStatus, `You can only upload up to ${MAX_THUMBNAILS} thumbnails. Please remove some first.`, 'warning', 4000);
             return;
         }
         
         // Process each file
         Array.from(files).forEach(file => {
             // Check if file is an image
             if (!file.type.startsWith('image/')) {
                 showStatus(styleAnalysisStatus, `File '${file.name}' is not an image. Skipping.`, 'warning', 3000);
                 return;
             }
             
             // Create a thumbnail preview
             const reader = new FileReader();
             reader.onload = function(event) {
                 // Create thumbnail object
                 const thumbnail = {
                     id: Date.now() + Math.random().toString(36).substring(2, 9), // Generate unique ID
                     file: file,
                     dataUrl: event.target.result
                 };
                 
                 // Add to array
                 uploadedThumbnails.push(thumbnail);
                 
                 // Create and add preview element
                 addThumbnailPreview(thumbnail);
             };
             reader.onerror = function(event) {
                 console.error("Error reading file:", event);
                 showStatus(styleAnalysisStatus, `Error reading file '${file.name}'.`, 'error', 3000);
             };
             reader.readAsDataURL(file);
         });
         
         // Reset file input
         e.target.value = '';
     }
     
     // Add thumbnail preview to the UI
     function addThumbnailPreview(thumbnail) {
         if (!thumbnailPreviewsDiv) return;
         
         // Create preview element
         const previewDiv = document.createElement('div');
         previewDiv.className = 'thumbnail-preview';
         previewDiv.dataset.id = thumbnail.id;
         
         // Create image
         const img = document.createElement('img');
         img.src = thumbnail.dataUrl;
         img.alt = 'Thumbnail preview';
         
         // Create remove button
         const removeButton = document.createElement('button');
         removeButton.className = 'remove-thumbnail';
         removeButton.innerHTML = '&times;';
         removeButton.addEventListener('click', () => removeThumbnail(thumbnail.id));
         
         // Add elements to preview
         previewDiv.appendChild(img);
         previewDiv.appendChild(removeButton);
         
         // Add to container
         thumbnailPreviewsDiv.appendChild(previewDiv);
         
         // Update UI state
         updateStyleUIState();
     }
     
     // Remove thumbnail
     function removeThumbnail(id) {
         // Remove from array
         uploadedThumbnails = uploadedThumbnails.filter(thumb => thumb.id !== id);
         
         // Remove from UI
         const previewElement = thumbnailPreviewsDiv?.querySelector(`.thumbnail-preview[data-id="${id}"]`);
         if (previewElement) {
             previewElement.remove();
         }
         
         // Update UI state
         updateStyleUIState();
     }
     
     // Update UI state based on uploaded thumbnails
     function updateStyleUIState() {
         if (!analyzeStyleButton) return;
         
         // Enable/disable analyze button based on whether thumbnails are uploaded
         analyzeStyleButton.disabled = uploadedThumbnails.length === 0;
         
         // Update button text to show count
         analyzeStyleButton.innerText = `Analyze Style (${uploadedThumbnails.length}/${MAX_THUMBNAILS}) (Cost: 5 Credits)`;
     }
     
     // Analyze style using ChatGPT
     // Analyze style using ChatGPT
async function analyzeStyle() {
    if (!currentSession || uploadedThumbnails.length === 0) {
        showStatus(styleAnalysisStatus, 'Please upload at least one thumbnail to analyze.', 'warning', 3000);
        return;
    }
    
    // Check if user has enough credits
    const CREDIT_COST_PER_STYLE_ANALYSIS = 5;
    if (currentUserCredits === null || currentUserCredits < CREDIT_COST_PER_STYLE_ANALYSIS) {
        const creditsTargetElement = creditsContainer ? creditsContainer.closest('.user-info-container > div') : null;
        showStatus(styleAnalysisStatus, `Insufficient credits. You need ${CREDIT_COST_PER_STYLE_ANALYSIS}.`, 'error', 4000);
        scrollToElement(creditsTargetElement?.id || 'credits-container');
        return;
    }
    
    // Disable button and show status
    if (analyzeStyleButton) {
        analyzeStyleButton.disabled = true;
        analyzeStyleButton.innerText = 'Analyzing...';
    }
    showStatus(styleAnalysisStatus, '🎨 Analyzing thumbnails... This may take up to a minute.', 'info');
    
    try {
        // Create FormData with all thumbnails
        const formData = new FormData();
        uploadedThumbnails.forEach((thumb, index) => {
            formData.append(`thumbnail_${index}`, thumb.file);
        });
        
        // Send to backend
        const token = currentSession.access_token;
        const res = await fetch(`${BACKEND_URL}/analyze_style`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`
            },
            body: formData
        });
        
        // Parse response
        const data = await res.json();
        
        // Handle errors
        if (!res.ok) {
            if (res.status === 401) throw new Error('Authentication error.');
            if (res.status === 403 && data.error?.includes('Insufficient credits')) throw new Error(data.error);
            throw new Error(data.error || `Server error: ${res.status}`);
        }
        
        // Handle success
        if (data.style_profile) {
            // Show result
            if (styleProfileResult) styleProfileResult.style.display = 'block';
            if (styleProfileJson) {
                // Format JSON for better readability
                const formattedJson = JSON.stringify(JSON.parse(data.style_profile), null, 2);
                styleProfileJson.value = formattedJson;
            }
            
            // Update credits
            if (data.new_credits !== undefined) {
                updateCreditState(data.new_credits);
            } else {
                fetchUserCredits(); // Fetch credits if backend didn't return them
            }
            
            // Show success message
            showStatus(styleAnalysisStatus, '✅ Style analysis completed!', 'success', 3000);
            scrollToElement('style-profile-result');
        } else {
            throw new Error('Server did not return a style profile.');
        }
    } catch (err) {
        console.error('Style Analysis Error:', err);
        showStatus(styleAnalysisStatus, `❌ Error: ${err.message}`, 'error', 6000);
        // Handle specific errors
        if (err.message?.includes("Authentication error")) { await logout(); }
        else if (err.message?.includes("Insufficient credits")) { await fetchUserCredits(); }
    } finally {
        // Re-enable button
        if (analyzeStyleButton) {
            analyzeStyleButton.disabled = false;
            updateStyleUIState();
        }
    }
}


// Save style profile
function saveStyleProfile() {
    if (!styleProfileJson || !styleNameInput) return;
    
    // Get style profile JSON and name
    const styleProfile = styleProfileJson.value.trim();
    const styleName = styleNameInput.value.trim();
    
    // Validate
    if (!styleProfile) {
        showStatus(styleAnalysisStatus, 'No style profile to save.', 'warning', 3000);
        return;
    }
    
    if (!styleName) {
        const styleNameWarning = document.getElementById('style-name-warning');
        if (styleNameWarning) {
            styleNameWarning.style.display = 'block';
            styleNameWarning.className = 'warning';
        }
        styleNameInput.focus();
        return;
    } else {
        const styleNameWarning = document.getElementById('style-name-warning');
        if (styleNameWarning) {
            styleNameWarning.style.display = 'none';
        }
    }
    
    if (!currentSession) {
        showStatus(styleAnalysisStatus, 'Please log in to save styles.', 'warning', 3000);
        return;
    }
    
    // Save to Supabase
    saveStyleToSupabase(styleName, styleProfile);
}
     
     // Save style to Supabase
     async function saveStyleToSupabase(name, profile) {
         try {
             const token = currentSession.access_token;
             const res = await fetch(`${BACKEND_URL}/style_profiles`, {
                 method: "POST",
                 headers: {
                     "Content-Type": "application/json",
                     "Authorization": `Bearer ${token}`
                 },
                 body: JSON.stringify({ name, profile })
             });
             
             const responseBody = await res.text();
             let data;
             try {
                 data = JSON.parse(responseBody);
             } catch(e) {
                 throw new Error(`Server returned invalid response (Status: ${res.status})`);
             }
             
             if (!res.ok) {
                 throw new Error(data.error || `Failed to save style profile (Status: ${res.status})`);
             }
             
             // Clear inputs
             styleNameInput.value = '';
             
             // Show success message
             showStatus(styleAnalysisStatus, `✅ Style "${name}" saved successfully!`, 'success', 3000);
             
             // Reload saved styles
             loadSavedStyles();
         } catch (err) {
             console.error("Error saving style profile:", err);
             showStatus(styleAnalysisStatus, `❌ Error: ${err.message}`, 'error', 4000);
             // Handle specific errors
             if (err.message?.includes("Authentication error")) { await logout(); }
         }
     }
// Helper function to add a style profile to the dropdown
function addStyleToDropdown(profile) {
    const styleProfileSelect = document.getElementById('styleProfileSelect');
    if (styleProfileSelect && profile && profile.name && profile.id) { // Use profile.name instead of profile.profile_name
        // Check if this profile ID already exists in the dropdown
        const existingOption = Array.from(styleProfileSelect.options).find(opt => opt.value === profile.id);
        if (existingOption) {
            console.warn(`Style profile with ID ${profile.id} already exists in dropdown. Skipping.`);
            return;
        }
        
        const option = document.createElement('option');
        option.value = profile.id; // Use profile ID as the value
        option.textContent = profile.name || 'Unnamed Profile'; // Use name, fallback if missing
        option.dataset.profileJson = profile.profile; // Store the actual profile JSON string in a data attribute
        styleProfileSelect.appendChild(option);
    } else {
        console.warn("Could not add style to dropdown. Element or profile data missing/invalid:", profile);
    }
}



// ----- Function to Create a Style Card Element (with Expand/Edit) -----
function createStyleCard(profile) {
    if (!profile || !profile.id || !profile.name) {
        console.error("Cannot create style card: profile data is incomplete.", profile);
        return null;
    }

    const card = document.createElement('div');
    card.className = 'style-card';
    card.dataset.profileId = profile.id;

    // Clickable Header for Name and Expand/Collapse
    const cardHeader = document.createElement('div');
    cardHeader.className = 'style-card-header'; // Add CSS for this
    cardHeader.style.display = 'flex';
    cardHeader.style.justifyContent = 'space-between';
    cardHeader.style.alignItems = 'center';
    cardHeader.style.cursor = 'pointer';
    
    const nameHeader = document.createElement('h3');
    nameHeader.textContent = profile.name;
    nameHeader.style.margin = '0';
    cardHeader.appendChild(nameHeader);
    
    const expandIndicator = document.createElement('span'); // Optional: for a +/- or arrow
    expandIndicator.className = 'expand-indicator';
    expandIndicator.textContent = ' [+]'; // Simple text indicator
    cardHeader.appendChild(expandIndicator);

    // JSON Viewer (hidden by default)
    const jsonViewer = document.createElement('div');
    jsonViewer.className = 'style-card-json-viewer'; // Add CSS for this
    jsonViewer.style.display = 'none';
    jsonViewer.style.padding = '10px';
    jsonViewer.style.backgroundColor = 'rgba(0,0,0,0.05)';
    jsonViewer.style.borderRadius = '4px';
    jsonViewer.style.marginTop = '8px';
    jsonViewer.style.marginBottom = '8px';
    jsonViewer.style.maxHeight = '300px';
    jsonViewer.style.overflow = 'auto';
    
    const pre = document.createElement('pre');
    pre.style.margin = '0';
    pre.style.whiteSpace = 'pre-wrap';
    pre.style.wordBreak = 'break-word';
    
    try {
        // Attempt to parse and re-stringify for pretty printing
        const parsedProfile = JSON.parse(profile.profile);
        pre.textContent = JSON.stringify(parsedProfile, null, 2);
    } catch (e) {
        console.warn(`Could not parse profile JSON for pretty printing (ID: ${profile.id}). Displaying raw.`, e);
        pre.textContent = profile.profile; // Fallback to raw string
    }
    jsonViewer.appendChild(pre);

    // Store the expanded state in a data attribute to maintain state
    card.dataset.expanded = 'false';
    
    cardHeader.addEventListener('click', () => {
        const isExpanded = card.dataset.expanded === 'true';
        jsonViewer.style.display = isExpanded ? 'none' : 'block';
        expandIndicator.textContent = isExpanded ? ' [+]' : ' [-]';
        card.dataset.expanded = isExpanded ? 'false' : 'true';
        
        // If edit form is visible, hide it when expanding/collapsing JSON
        if (editForm.style.display === 'block' && !isExpanded) {
            // This case should ideally not happen if edit mode hides the header,
            // but as a safe guard:
            // editForm.style.display = 'none';
            // actionsDiv.style.display = 'flex'; // Or your original display type
        }
    });

    // Edit Form (hidden by default)
    const editForm = document.createElement('div');
    editForm.className = 'style-card-edit-form'; // Add CSS for this
    editForm.style.display = 'none';
    editForm.style.padding = '10px';
    editForm.style.backgroundColor = 'rgba(0,0,0,0.03)';
    editForm.style.borderRadius = '4px';
    editForm.style.marginTop = '8px';

    const nameLabel = document.createElement('label');
    nameLabel.textContent = 'Style Name:';
    nameLabel.htmlFor = `edit-style-name-${profile.id}`;
    nameLabel.style.display = 'block';
    nameLabel.style.marginBottom = '4px';
    nameLabel.style.fontWeight = 'bold';
    
    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.id = `edit-style-name-${profile.id}`;
    nameInput.value = profile.name;
    nameInput.style.width = '100%';
    nameInput.style.padding = '8px';
    nameInput.style.marginBottom = '12px';
    nameInput.style.borderRadius = '4px';
    nameInput.style.border = '1px solid var(--border-color)';

    const jsonLabel = document.createElement('label');
    jsonLabel.textContent = 'Profile JSON:';
    jsonLabel.htmlFor = `edit-style-json-${profile.id}`;
    jsonLabel.style.display = 'block';
    jsonLabel.style.marginBottom = '4px';
    jsonLabel.style.fontWeight = 'bold';
    
    const jsonTextarea = document.createElement('textarea');
    jsonTextarea.id = `edit-style-json-${profile.id}`;
    jsonTextarea.rows = 10; // Adjust as needed
    jsonTextarea.value = profile.profile;
    jsonTextarea.style.width = '100%';
    jsonTextarea.style.padding = '8px';
    jsonTextarea.style.marginBottom = '12px';
    jsonTextarea.style.borderRadius = '4px';
    jsonTextarea.style.border = '1px solid var(--border-color)';
    jsonTextarea.style.fontFamily = 'monospace';
    jsonTextarea.style.fontSize = '14px';

    const saveEditButton = document.createElement('button');
    saveEditButton.textContent = 'Save Changes';
    saveEditButton.className = 'button primary-button';
    saveEditButton.style.marginRight = '8px';
    saveEditButton.addEventListener('click', async () => {
        const updatedName = nameInput.value.trim();
        const updatedProfileJson = jsonTextarea.value.trim();
        const statusP = document.getElementById('style-analysis-status') || document.getElementById('status');

        if (!updatedName) {
            if (statusP) showStatus(statusP, 'Style name cannot be empty.', 'error', 3000);
            else alert('Style name cannot be empty.');
            nameInput.focus();
            return;
        }
        try {
            JSON.parse(updatedProfileJson); // Validate JSON
        } catch (e) {
            if (statusP) showStatus(statusP, 'Invalid JSON in profile.', 'error', 4000);
            else alert('Invalid JSON in profile.');
            jsonTextarea.focus();
            return;
        }

        // Show loading state
        saveEditButton.disabled = true;
        saveEditButton.textContent = 'Saving...';

        const success = await updateStyleInSupabase(profile.id, { name: updatedName, profile: updatedProfileJson });
        
        // Reset button state
        saveEditButton.disabled = false;
        saveEditButton.textContent = 'Save Changes';
        
        if (success) {
            // Hide edit form and restore view
            editForm.style.display = 'none';
            cardHeader.style.display = 'flex';
            actionsDiv.style.display = 'flex';
            
            // Update the name header with the new name
            nameHeader.textContent = updatedName;
            
            // Update the JSON viewer with the new content
            try {
                const parsedProfile = JSON.parse(updatedProfileJson);
                pre.textContent = JSON.stringify(parsedProfile, null, 2);
            } catch (e) {
                pre.textContent = updatedProfileJson;
            }
            
            // If it was expanded, keep it expanded
            if (card.dataset.expanded === 'true') {
                jsonViewer.style.display = 'block';
            }
        } else {
            // Error message already shown by updateStyleInSupabase
        }
    });

    const cancelEditButton = document.createElement('button');
    cancelEditButton.textContent = 'Cancel';
    cancelEditButton.className = 'button secondary-button';
    cancelEditButton.addEventListener('click', () => {
        // Reset form values to original
        nameInput.value = profile.name;
        jsonTextarea.value = profile.profile;
        // Toggle visibility
        editForm.style.display = 'none';
        cardHeader.style.display = 'flex'; // Or your original display type for header
        
        // Restore JSON viewer state based on expanded state
        if (card.dataset.expanded === 'true') {
            jsonViewer.style.display = 'block';
            expandIndicator.textContent = ' [-]';
        } else {
            jsonViewer.style.display = 'none';
            expandIndicator.textContent = ' [+]';
        }
        
        actionsDiv.style.display = 'flex'; // Or your original display type
    });

    editForm.appendChild(nameLabel);
    editForm.appendChild(nameInput);
    editForm.appendChild(document.createElement('br'));
    editForm.appendChild(jsonLabel);
    editForm.appendChild(jsonTextarea);
    editForm.appendChild(document.createElement('br'));
    editForm.appendChild(saveEditButton);
    editForm.appendChild(cancelEditButton);

    // Action Buttons (Use, Edit, Delete)
    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'style-card-actions';
    actionsDiv.style.display = 'flex';
    actionsDiv.style.justifyContent = 'flex-start';
    actionsDiv.style.gap = '8px';
    actionsDiv.style.marginTop = '8px';

    const useButton = document.createElement('button');
    useButton.textContent = 'Use';
    useButton.className = 'button primary-button';
    useButton.style.padding = '6px 12px';
    useButton.style.fontSize = '14px';
    useButton.addEventListener('click', () => {
        // (Existing Use button logic - copied from your previous working version)
        console.log(`Use button clicked for profile: ${profile.name}`, profile);
        const styleProfileSelect = document.getElementById('styleProfileSelect');
        const statusP = document.getElementById('style-analysis-status') || document.getElementById('prompt-status') || document.getElementById('status');
        if (styleProfileSelect) {
            styleProfileSelect.value = profile.id;
            const promptGenTabButton = document.getElementById('tab-prompt-gen');
            if (promptGenTabButton && !promptGenTabButton.classList.contains('active')) {
                handleTabSwitch(promptGenTabButton);
            }
            scrollToElement('styleProfileSelect');
            if(statusP) showStatus(statusP, `Selected style profile: \"${profile.name}\"`, 'info', 3000);
            else alert(`Selected style profile: \"${profile.name}\"`);
        } else {
            if(statusP) showStatus(statusP, 'Error: Style profile dropdown not found.', 'error', 3000);
            else alert('Error: Style profile dropdown not found.');
        }
    });

    const editButton = document.createElement('button');
    editButton.textContent = 'Edit';
    editButton.className = 'button secondary-button';
    editButton.style.padding = '6px 12px';
    editButton.style.fontSize = '14px';
    editButton.addEventListener('click', () => {
        cardHeader.style.display = 'none'; // Hide header
        jsonViewer.style.display = 'none'; // Hide JSON viewer
        actionsDiv.style.display = 'none'; // Hide action buttons
        editForm.style.display = 'block';  // Show edit form
        nameInput.value = profile.name;    // Ensure form is populated
        jsonTextarea.value = profile.profile;
        
        // Focus on the name input for better UX
        setTimeout(() => nameInput.focus(), 0);
    });

    const deleteButton = document.createElement('button');
    deleteButton.textContent = 'Delete';
    deleteButton.className = 'button secondary-button';
    deleteButton.style.padding = '6px 12px';
    deleteButton.style.fontSize = '14px';
    deleteButton.addEventListener('click', (event) => {
        event.stopPropagation();
        if (confirm(`Are you sure you want to delete the style profile \"${profile.name}\"?`)) {
            deleteStyleFromSupabase(profile.id);
        }
    });

    actionsDiv.appendChild(useButton);
    actionsDiv.appendChild(editButton); // Added Edit button
    actionsDiv.appendChild(deleteButton);

    // Style the card itself
    card.style.border = '1px solid var(--border-color)';
    card.style.borderRadius = '8px';
    card.style.padding = '12px';
    card.style.marginBottom = '16px';
    card.style.backgroundColor = 'var(--card-bg)';
    
    // Append main elements to card
    card.appendChild(cardHeader);
    card.appendChild(jsonViewer);
    card.appendChild(editForm);
    card.appendChild(actionsDiv);

    return card;
}

     
                    // Load saved styles from Supabase and update UI elements
            async function loadSavedStyles() {
              console.log("Executing loadSavedStyles...");
              // --- Get references to UI elements ---
              const styleProfileSelect = document.getElementById('styleProfileSelect'); // Dropdown in Image Gen tab
              const savedStylesListContainer = document.getElementById('saved-styles-list'); // Container for style cards in Styles tab
              const noSavedStylesMsgElement = document.getElementById('no-saved-styles-message');   // Message when no styles in Styles tab
              const styleStatusPElement = document.getElementById('style-status');        // Status message element in Styles tab
     
              // --- Reset UI Elements ---
              if (savedStylesListContainer) savedStylesListContainer.innerHTML = ''; // Clear old cards
              if (noSavedStylesMsgElement) noSavedStylesMsgElement.style.display = 'none'; // Hide message initially
              
              // Reset dropdown specifically
              if (styleProfileSelect) {
                  styleProfileSelect.innerHTML = '<option value="">-- Loading... --</option>';
                  styleProfileSelect.disabled = true;
              } else {
                  console.warn("Style profile select dropdown (#styleProfileSelect) not found in the DOM.");
              }
     
              // --- Check Authentication ---
              if (!currentSession) {
                  console.log("loadSavedStyles: No active session. Styles cannot be loaded.");
                  if (noSavedStylesMsgElement) {
                      noSavedStylesMsgElement.textContent = 'Please log in to view saved styles.';
                      noSavedStylesMsgElement.style.display = 'block';
                  }
                  if (styleProfileSelect) {
                      styleProfileSelect.innerHTML = '<option value="">-- Log in --</option>';
                      // Keep it disabled
                  }
                  if (styleStatusPElement) showStatus(styleStatusPElement, ''); // Clear status message
                  return; // Exit if not logged in
              }
     
              // --- Fetch Styles --- 
              try {
                  const token = currentSession.access_token;
                  const response = await fetch(`${BACKEND_URL}/style_profiles`, {
                      headers: { 'Authorization': `Bearer ${token}` }
                  });
              
                  if (!response.ok) {
                      const errorData = await response.json().catch(() => ({ error: `HTTP error ${response.status}` }));
                      throw new Error(errorData.error || `Failed to fetch styles`);
                  }
              
                  const responseData = await response.json(); // Get the full response object
                  let styles = responseData.profiles;      // Extract the 'profiles' array
                  console.log("Fetched styles:", styles);    // Should now log the array

                  // Filter out duplicate styles based on ID
                  if (Array.isArray(styles)) {
                      const uniqueIds = new Set();
                      styles = styles.filter(profile => {
                          if (!profile || !profile.id) {
                              console.warn('Invalid profile found without ID. Removing it.');
                              return false;
                          }
                          if (uniqueIds.has(profile.id)) {
                              console.warn(`Duplicate style profile found with ID: ${profile.id}. Removing duplicate.`);
                              return false;
                          }
                          uniqueIds.add(profile.id);
                          return true;
                      });
                      console.log("After removing duplicates:", styles);
                  }
              
                  // --- Update UI based on fetched data --- 
              
                  // Reset dropdown to default "None" before populating
                  if (styleProfileSelect) {
                      styleProfileSelect.innerHTML = '<option value="">-- None --</option>';
                  }
              
                  // Ensure 'styles' is actually an array before proceeding
                  if (!Array.isArray(styles) || styles.length === 0) { 
                      // No styles found
                      if (noSavedStylesMsgElement) {
                          noSavedStylesMsgElement.textContent = 'No saved styles found. Create one below!';
                          noSavedStylesMsgElement.style.display = 'block';
                      }
                      if (styleProfileSelect) {
                          styleProfileSelect.disabled = true; // Keep dropdown disabled as there are no options
                      }
                      console.log("No saved styles found for the user or response was not an array.");
                  } else {
                      // Styles found - populate cards and dropdown
                      if (noSavedStylesMsgElement) noSavedStylesMsgElement.style.display = 'none'; // Hide "no styles" message
                      
                      if (styleProfileSelect) {
                          styleProfileSelect.disabled = false; // Enable dropdown since there are options
                      }
                      
                      // Populate dropdown and cards
                      styles.forEach(profile => {
                          console.log("Processing profile:", profile);
                           
                          // Call helper to add to dropdown
                          addStyleToDropdown(profile); 
     
                          // Create and add style card to the UI
                          if (savedStylesListContainer) {
                              // Check if a card with this profile ID already exists
                              const existingCard = savedStylesListContainer.querySelector(`[data-profile-id="${profile.id}"]`);
                              if (existingCard) {
                                  console.warn(`Style card with ID ${profile.id} already exists in the UI. Skipping.`);
                                  return;
                              }
                              
                              const cardElement = createStyleCard(profile);
                              if (cardElement) {
                                  savedStylesListContainer.appendChild(cardElement);
                              }
                          }
                      });
     
                      // Log after populating
                      console.log("Styles loaded and UI populated (cards & dropdown).");
                  }
                  if (styleStatusPElement) showStatus(styleStatusPElement, ''); // Clear any previous error status message
     
              } catch (error) {
                  console.error('❌ Error during loadSavedStyles:', error);
                  if (styleStatusPElement) showStatus(styleStatusPElement, `Error loading styles: ${error.message}`, 'error');
                  // Reset UI elements to an error state
                  if (savedStylesListContainer) savedStylesListContainer.innerHTML = ''; // Clear potentially partial cards
                  if (noSavedStylesMsgElement) {
                      noSavedStylesMsgElement.textContent = 'Could not load styles.';
                      noSavedStylesMsgElement.style.display = 'block';
                  }
                  if (styleProfileSelect) {
                      styleProfileSelect.innerHTML = '<option value="">-- Error --</option>';
                      styleProfileSelect.disabled = true;
                  }
                  // Specific error handling can be added here, e.g., for authentication errors
                  if (error.message?.includes("auth")) {
                      console.warn("Authentication error detected while loading styles.");
                      // Consider actions like logging out the user or prompting re-login
                  }
              }
          }
     
     // Get saved styles from Supabase
     async function getSavedStylesFromSupabase() {
         if (!currentSession) {
             // If not logged in, show message and return
             return [];
         }
         
         try {
             const token = currentSession.access_token;
             const res = await fetch(`${BACKEND_URL}/style_profiles`, {
                 method: "GET",
                 headers: {
                     "Content-Type": "application/json",
                     "Authorization": `Bearer ${token}`
                 }
             });
             
             const responseBody = await res.text();
             let data;
             try {
                 data = JSON.parse(responseBody);
             } catch(e) {
                 throw new Error(`Server returned invalid response (Status: ${res.status})`);
             }
             
             if (!res.ok) {
                 throw new Error(data.error || `Failed to load styles (Status: ${res.status})`);
             }
             
             return data.profiles || [];
         } catch (err) {
             console.error("Error loading styles:", err);
             return [];
         }
     }
     
     // Update style in Supabase
     async function updateStyleInSupabase(styleId, updatedData) {
         try {
             const token = currentSession.access_token;
             const res = await fetch(`${BACKEND_URL}/style_profiles/${styleId}`, {
                 method: "PUT",
                 headers: {
                     "Content-Type": "application/json",
                     "Authorization": `Bearer ${token}`
                 },
                 body: JSON.stringify(updatedData)
             });
             
             const responseBody = await res.text();
             let data;
             try {
                 data = JSON.parse(responseBody);
             } catch(e) {
                 throw new Error(`Server returned invalid response (Status: ${res.status})`);
             }
             
             if (!res.ok) {
                 throw new Error(data.error || `Failed to update style (Status: ${res.status})`);
             }
             
             // Show success message
             showStatus(styleAnalysisStatus, `✅ Style "${updatedData.name}" updated successfully!`, 'success', 3000);
             
             // Reload saved styles to reflect changes immediately
             loadSavedStyles();
             
             return true;
         } catch (err) {
             console.error("Error updating style:", err);
             showStatus(styleAnalysisStatus, `❌ Error: ${err.message}`, 'error', 4000);
             // Handle specific errors
             if (err.message?.includes("Authentication error")) { await logout(); }
             return false;
         }
     }
     
     // Delete style from Supabase
     async function deleteStyleFromSupabase(styleId) {
         try {
             const token = currentSession.access_token;
             const res = await fetch(`${BACKEND_URL}/style_profiles/${styleId}`, {
                 method: "DELETE",
                 headers: {
                     "Content-Type": "application/json",
                     "Authorization": `Bearer ${token}`
                 }
             });
             
             const responseBody = await res.text();
             let data;
             try {
                 data = JSON.parse(responseBody);
             } catch(e) {
                 throw new Error(`Server returned invalid response (Status: ${res.status})`);
             }
             
             if (!res.ok) {
                 throw new Error(data.error || `Failed to delete style (Status: ${res.status})`);
             }
             
             // Show success message
             showStatus(styleAnalysisStatus, `✅ Style deleted successfully!`, 'success', 3000);
             
             // Reload saved styles
             loadSavedStyles();
         } catch (err) {
             console.error("Error deleting style:", err);
             showStatus(styleAnalysisStatus, `❌ Error: ${err.message}`, 'error', 4000);
             // Handle specific errors
             if (err.message?.includes("Authentication error")) { await logout(); }
         }
     }
     // --- Initialization and Auth State Change Listener ---
     // Preload fonts for better performance
     function preloadFonts() {
         availableFontFiles.forEach(filename => {
             const link = document.createElement('link');
             link.rel = 'preload';
             link.href = `${globalFontPath}${filename}`;
             link.as = 'font';
             link.type = 'font/ttf';
             link.crossOrigin = 'anonymous';
             document.head.appendChild(link);
             console.log(`Preloading font: ${globalFontPath}${filename}`);
         });
     }
     
     document.addEventListener('DOMContentLoaded', async () => {
         // Check and update font path
         await checkAndUpdateFontPath();
         
         // Debug font loading
         debugFontLoading();
         
         // Preload fonts
         preloadFonts();
         
         // Check for password reset flow in URL
         const hash = window.location.hash;
         if (hash && hash.includes('type=recovery')) {
             console.log("Password reset flow detected from URL hash");
             // The auth state change listener will handle showing the update password modal
             // when the PASSWORD_RECOVERY event fires
         } else if (hash && hash.includes('error=access_denied') && hash.includes('error_code=otp_expired')) {
             console.log("Expired password reset link detected");
             showStatus(authStatusP, "Your password reset link has expired. Please request a new one.", 'error', 10000);
             // Add a button to open the forgot password modal
             const resetButton = document.createElement('button');
             resetButton.innerText = 'Reset Password Again';
             resetButton.style.marginTop = '0.5rem';
             resetButton.style.width = '100%';
             resetButton.onclick = () => showForgotPasswordModal();
             
             // Add the reset button to the auth status area
             if (authStatusP.nextElementSibling && authStatusP.nextElementSibling.classList.contains('reset-button')) {
                 authStatusP.nextElementSibling.remove();
             }
             authStatusP.parentNode.insertBefore(resetButton, authStatusP.nextSibling);
             resetButton.classList.add('reset-button');
         }
         // Attach Tab Listeners
         console.log("DOM Content Loaded - Attaching Tab Listeners..."); // Add log
         
         // Attach forgot password link listener
         const forgotPasswordLink = document.getElementById('forgot-password-link');
         if (forgotPasswordLink) {
             forgotPasswordLink.addEventListener('click', (e) => {
                 e.preventDefault();
                 showForgotPasswordModal();
             });
             console.log("Attached listener to forgotPasswordLink");
         } else {
             console.warn("forgotPasswordLink not found");
         }
         
         if (promptGenTabButton) {
             promptGenTabButton.addEventListener('click', () => handleTabSwitch(promptGenTabButton));
             console.log("Attached listener to promptGenTabButton");
         } else { console.warn("promptGenTabButton not found"); }
         if (assetExtractionTabButton) {
              assetExtractionTabButton.addEventListener('click', () => handleTabSwitch(assetExtractionTabButton));
              console.log("Attached listener to assetExtractionTabButton");
         } else { console.warn("assetExtractionTabButton not found"); }
          
          // Add missing event listener for Style Profile tab
          if (styleProfileTabButton) {
               styleProfileTabButton.addEventListener('click', () => handleTabSwitch(styleProfileTabButton));
               console.log("Attached listener to styleProfileTabButton");
          } else { console.warn("styleProfileTabButton not found"); }


          // ---> Attach Asset History Button Listeners HERE <---
         console.log("Attaching Asset History Listeners...");
         if (assetHistoryButton) {
             assetHistoryButton.addEventListener('click', () => fetchAssetHistory(false));
              console.log("Attached listener to assetHistoryButton");
         } else {
             console.error("ERROR: assetHistoryButton element NOT FOUND during DOMContentLoaded!");
         }
         if (assetHistoryLoadMoreButton) {
             assetHistoryLoadMoreButton.addEventListener('click', () => fetchAssetHistory(true));
              console.log("Attached listener to assetHistoryLoadMoreButton");
         } else {
             console.warn("assetHistoryLoadMoreButton not found (this might be ok if history isn't loaded yet)");
         }
          // ---> End History Listener Attachment <---


         // Check for payment status from Stripe redirect
         const urlParams = new URLSearchParams(window.location.search);
         const paymentStatus = urlParams.get('payment');
         const statusTargetElement = purchaseStatusP; // Target header status

         if (statusTargetElement) {
             if (paymentStatus === 'success') {
                 showStatus(statusTargetElement, "✅ Payment successful! Credits updating...", 'success');
                 setTimeout(() => { if (currentSession) fetchUserCredits(); }, 4000);
                 setTimeout(() => { if (statusTargetElement.innerText.includes("Payment successful")) showStatus(statusTargetElement, ''); }, 10000);
                 if (window.history.replaceState) window.history.replaceState(null, '', window.location.pathname + window.location.hash);
             } else if (paymentStatus === 'cancel') {
                 showStatus(statusTargetElement, "⚠️ Purchase cancelled.", 'warning', 5000);
                 if (window.history.replaceState) window.history.replaceState(null, '', window.location.pathname + window.location.hash);
             }
         }
         // Initial view setup is handled by onAuthStateChange
     });

     // NOTE: Need listener for Thumbnail history load more button outside DOMContentLoaded
     if (loadMoreButton) { loadMoreButton.addEventListener('click', () => fetchHistory(true)); }
     // The listener for the main thumbnail history button #history-button uses onclick in the HTML
     // The listener for asset extraction button #extract-asset-button is attached directly below the function def

     // Auth state change listener
     supabaseClient.auth.onAuthStateChange((event, session) => {
        console.log('--- Supabase Auth Event ---:', event, session ? `User: ${session.user?.id}` : "No session");
        
        // Store previous session state
        const previousSession = currentSession;
        
        // Handle specific auth events
        if (event === 'SIGNED_IN') {
            // Check if email is verified
            if (session && session.user && session.user.email_confirmed_at) {
                console.log('User signed in with verified email');
                currentSession = session;
            } else if (session && session.user) {
                            console.log('User signed in but email is not verified');
            showStatus(authStatusP, 'Please verify your email before logging in. Check your inbox (and spam folder) for a verification link.', 'warning', 10000);
                // Force logout if email not verified
                supabaseClient.auth.signOut();
                currentSession = null;
            }
        } else if (event === 'SIGNED_OUT') {
            console.log('User signed out');
            currentSession = null;
        } else if (event === 'USER_UPDATED') {
            // This could be triggered when a user verifies their email
            console.log('User updated');
            if (session && session.user && session.user.email_confirmed_at) {
                currentSession = session;
            }
        } else {
            // For other events, just update the session
            currentSession = session;
        }

         // Determine if a major UI update is needed
         const needsFullUpdate =
             event === 'INITIAL_SESSION' ||
             (event === 'SIGNED_IN' && !previousSession) || // Logged in from null state
             (event === 'SIGNED_OUT' && previousSession);   // Logged out from logged in state

         if (needsFullUpdate) {
             console.log(` ---> Triggering full UI update (updateContentView) for event: ${event}`);
              updateContentView(); // Set up basic view (logged in/out, tabs)
              if (session) {
                  console.log(` ---> Session exists, triggering fetchUserCredits`);
                   fetchUserCredits(); // Fetch credits and update buttons etc.
                  
                   // Load styles for the current user
                   console.log(` ---> Session exists, triggering loadSavedStyles`);
                   loadSavedStyles(); // Load styles for the logged-in user
              } else {
                  console.log(` ---> Session is null, triggering updateCreditState(null)`);
                   updateCreditState(null); // Ensure credits UI is reset
                   
                   // Clear styles list when logged out
                   console.log(` ---> Session is null, clearing saved styles list.`);
                   if (savedStylesList) savedStylesList.innerHTML = ''; // Clear the visual list
                   if (noSavedStylesMessage) {
                       noSavedStylesMessage.style.display = 'block'; 
                       noSavedStylesMessage.textContent = 'Please log in to view your saved styles.';
                   }
              }
         } else if (session && (event === "TOKEN_REFRESHED" || event === "USER_UPDATED")) {
             // If already logged in and token refreshes or user updates, just fetch credits
             console.log(` ---> Event ${event} received while logged in, triggering fetchUserCredits`);
              fetchUserCredits();
         } else {
             console.log(` ---> Event ${event} did not trigger specific action.`);
             if (event === "PASSWORD_RECOVERY") {
                 console.log("Password recovery flow detected");
                 showStatus(authStatusP, "Please set your new password", 'info');
                 showUpdatePasswordModal();
             }
         }
     });

     // Initialize style profile functionality
     initStyleProfile();
 </script>

</body>
</html>

